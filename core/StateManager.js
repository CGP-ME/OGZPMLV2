/**
 * @fileoverview StateManager - Single Source of Truth for Trading State
 *
 * This module centralizes ALL trading state management with atomic updates.
 * It prevents the critical position/balance desync bugs that occurred when
 * multiple components tracked state independently.
 *
 * @description
 * ARCHITECTURE ROLE:
 * StateManager sits at the center of the trading system. Every component
 * (TradingBrain, ExecutionLayer, RiskManager) MUST read from and write to
 * StateManager rather than maintaining their own state copies.
 *
 * HISTORICAL BUGS FIXED:
 * - Position desync: this.currentPosition vs this.tradingBrain.position
 * - Balance desync: Multiple components tracking different balances
 * - P&L calculation: BTC treated as USD (lost $99.99 per trade)
 * - activeTrades accumulation: Closed trades not removed from Map
 *
 * CRITICAL INVARIANTS:
 * 1. position is always in BTC (asset units), NOT USD
 * 2. balance is always in USD
 * 3. inPosition tracks USD locked in positions (position Ã— entryPrice)
 * 4. totalBalance = balance + inPosition + unrealizedPnL
 * 5. All updates go through updateState() for atomicity
 *
 * @module core/StateManager
 * @requires fs
 * @requires path
 *
 * @example
 * // Get the singleton instance
 * const { getInstance } = require('./core/StateManager');
 * const stateManager = getInstance();
 *
 * // Open a position (size in BTC)
 * await stateManager.openPosition(0.001, 100000, { source: 'TradingBrain' });
 *
 * // Close position
 * await stateManager.closePosition(101000);
 *
 * // Check current state
 * const state = stateManager.getState();
 * console.log(`Balance: $${state.balance}, Position: ${state.position} BTC`);
 */

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION: StateManager Class
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Centralized state management for trading operations.
 * Implements atomic updates, state persistence, and change notifications.
 *
 * @class StateManager
 * @property {Object} state - The current trading state
 * @property {number} state.position - Current position size in BTC (NOT USD!)
 * @property {number} state.positionCount - Number of entries (for averaging)
 * @property {number} state.entryPrice - Average entry price in USD
 * @property {Date|null} state.entryTime - When position was opened
 * @property {number} state.balance - Available USD balance (not in positions)
 * @property {number} state.totalBalance - Total account value in USD
 * @property {number} state.inPosition - USD value locked in positions
 * @property {Map} state.activeTrades - Active trade records (orderId â†’ trade)
 * @property {number} state.realizedPnL - Cumulative realized profit/loss
 * @property {number} state.unrealizedPnL - Current unrealized P&L
 * @property {boolean} state.isTrading - Whether trading is active
 * @property {boolean} state.recoveryMode - Emergency recovery mode flag
 */
class StateManager {
  /**
   * Creates a new StateManager instance.
   * Initializes default state, sets up listeners, and loads persisted state.
   *
   * @constructor
   * @note This should only be called by getInstance() - use the singleton!
   */
  constructor() {
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // POSITION TRACKING
    // CRITICAL: position is in BTC (asset units), NOT USD!
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    this.state = {
      position: 0,              // Current position size in BTC (ASSET UNITS!)
      positionCount: 0,         // Number of entries (for DCA/averaging)
      entryPrice: 0,            // Average entry price in USD
      entryTime: null,          // Timestamp when position was opened

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // BALANCE TRACKING (all values in USD)
      // Invariant: totalBalance â‰ˆ balance + inPosition + unrealizedPnL
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      balance: 10000,           // Available USD (not locked in positions)
      totalBalance: 10000,      // Total account value in USD
      inPosition: 0,            // USD locked in positions (position Ã— entryPrice)

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // TRADE TRACKING
      // activeTrades Map persists across restarts via save()/load()
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      activeTrades: new Map(),  // orderId â†’ { size, price, entryTime, ... }
      lastTradeTime: null,      // Timestamp of last trade execution
      tradeCount: 0,            // Total trades (lifetime)
      dailyTradeCount: 0,       // Trades today (resets via resetDaily())

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // P&L TRACKING (all values in USD)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      realizedPnL: 0,           // Cumulative closed trade P&L
      unrealizedPnL: 0,         // Current open position P&L (updated externally)
      totalPnL: 0,              // realizedPnL + unrealizedPnL

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // SYSTEM STATE
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      isTrading: false,         // false = paused/stopped
      recoveryMode: false,      // true = emergency mode active
      lastError: null,          // Last error message (for pause reason)
      lastUpdate: Date.now()    // Timestamp of last state update
    };

    /** @type {Set<Function>} Listeners notified on state changes */
    this.listeners = new Set();

    /** @type {Array<Object>} Rolling log of recent transactions for debugging */
    this.transactionLog = [];
    this.maxLogSize = 100;

    /** @type {boolean} Lock flag for atomic operations */
    this.locked = false;
    /** @type {Array<Function>} Queue of callbacks waiting for lock */
    this.lockQueue = [];

    // Bind methods to preserve 'this' context when passed as callbacks
    this.get = this.get.bind(this);
    this.set = this.set.bind(this);
    this.updateActiveTrade = this.updateActiveTrade.bind(this);
    this.removeActiveTrade = this.removeActiveTrade.bind(this);
    this.openPosition = this.openPosition.bind(this);
    this.closePosition = this.closePosition.bind(this);

    // Load persisted state from disk (respects BACKTEST_MODE, FRESH_START)
    this.load();
  }

  /**
   * Get current state snapshot (read-only)
   */
  getState() {
    return { ...this.state };
  }

  /**
   * Get specific state value
   */
  get(key) {
    return this.state[key];
  }

  /**
   * Set specific state value (for internal use)
   */
  set(key, value) {
    this.state[key] = value;
    return value;
  }

  /**
   * ATOMIC state update with transaction safety
   * All state changes MUST go through this
   */
  async updateState(updates, context = {}) {
    // Wait for lock
    await this.acquireLock();

    try {
      // Snapshot for rollback
      const snapshot = { ...this.state };
      const timestamp = Date.now();

      // Validate updates
      this.validateUpdates(updates);

      // Apply updates atomically
      for (const [key, value] of Object.entries(updates)) {
        // DEBUG: Log balance changes
        if (key === 'balance') {
          console.log(`ğŸ’° [StateManager] Balance update: ${this.state[key]} â†’ ${value}`);
        }

        // CRITICAL FIX: Protect activeTrades Map from being overwritten
        if (key === 'activeTrades') {
          // If it's an array, convert to Map
          if (Array.isArray(value)) {
            this.state.activeTrades = new Map(value);
            console.log(`ğŸ”§ [StateManager] Converted activeTrades array to Map with ${value.length} entries`);
          } else if (value instanceof Map) {
            this.state.activeTrades = value;
          } else {
            console.warn(`âš ï¸ [StateManager] Ignoring invalid activeTrades update (not Array or Map):`, value);
            continue; // Skip this update
          }
        } else {
          this.state[key] = value;
        }
      }

      this.state.lastUpdate = timestamp;

      // Log transaction
      this.logTransaction({
        timestamp,
        updates,
        context,
        snapshot
      });

      // Notify listeners
      this.notifyListeners(updates, context);

      // CHANGE 2025-12-13: Save state to disk after updates
      this.save();

      return { success: true, state: this.getState() };

    } catch (error) {
      console.error('[StateManager] Update failed:', error);
      // Rollback would go here if needed
      return { success: false, error: error.message };

    } finally {
      this.releaseLock();
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SECTION: Position Management
  // These methods handle opening/closing positions with proper BTCâ†”USD math
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * Open a new position (BUY).
   *
   * @async
   * @param {number} size - Position size in BTC (asset units, NOT USD!)
   * @param {number} price - Current market price in USD per BTC
   * @param {Object} [context={}] - Additional context for logging/tracking
   * @param {string} [context.orderId] - Broker order ID
   * @param {string} [context.source] - Calling component (e.g., 'TradingBrain')
   * @param {string} [context.reason] - Trade reason (e.g., 'RSI oversold')
   * @param {number} [context.confidence] - Signal confidence (0-100)
   * @returns {Promise<{success: boolean, state?: Object, error?: string}>}
   *
   * @example
   * // Buy 0.001 BTC at $100,000
   * await stateManager.openPosition(0.001, 100000, {
   *   source: 'TradingBrain',
   *   reason: 'RSI oversold bounce',
   *   confidence: 75
   * });
   * // Result: balance -= $100, position = 0.001, inPosition = $100
   *
   * @description
   * CRITICAL MATH:
   * - size is in BTC (e.g., 0.001)
   * - price is in USD per BTC (e.g., $100,000)
   * - usdCost = size Ã— price (e.g., 0.001 Ã— 100,000 = $100)
   * - balance decreases by usdCost
   * - inPosition increases by usdCost
   * - position increases by size (BTC)
   */
  async openPosition(size, price, context = {}) {
    if (this.state.position > 0) {
      console.warn('[StateManager] Already in position, adding to it');
    }

    // DEBUG: Log what we're doing
    const usdCost = size * price;  // Calculate USD cost
    console.log(`ğŸ“Š [StateManager] Opening position:`);
    console.log(`   Size: ${size} BTC`);
    console.log(`   Price: $${price}`);
    console.log(`   USD Cost: $${usdCost.toFixed(2)}`);
    console.log(`   Current Balance: $${this.state.balance}`);
    console.log(`   New Balance: $${(this.state.balance - usdCost).toFixed(2)}`);

    // CRITICAL FIX: Add trade to activeTrades Map
    const tradeId = context.orderId || `TRADE_${Date.now()}`;
    const trade = {
      id: tradeId,
      action: 'BUY',  // FIX: Changed from 'type' to 'action' to match run-empire filter
      type: 'BUY',    // Keep both for compatibility
      size: size,
      price: price,
      entryPrice: price,  // Add entryPrice field that run-empire expects
      entryTime: Date.now(),  // Add entryTime field
      timestamp: Date.now(),
      status: 'open',
      ...context
    };

    // Add to activeTrades Map
    if (!this.state.activeTrades) {
      this.state.activeTrades = new Map();
    }
    this.state.activeTrades.set(tradeId, trade);
    console.log(`âœ… [StateManager] Added trade ${tradeId} to activeTrades (now ${this.state.activeTrades.size} trades)`);

    // usdCost already calculated above (line 167)
    const updates = {
      position: this.state.position + size,  // Track BTC position
      positionCount: this.state.positionCount + 1,
      entryPrice: this.state.position > 0
        ? (this.state.entryPrice * this.state.position + price * size) / (this.state.position + size)
        : price,
      entryTime: this.state.entryTime || Date.now(),
      balance: this.state.balance - usdCost,  // Subtract USD cost
      inPosition: this.state.inPosition + usdCost,  // BUGFIX: Track USD in position, not BTC!
      lastTradeTime: Date.now(),
      tradeCount: this.state.tradeCount + 1,
      dailyTradeCount: this.state.dailyTradeCount + 1
    };

    return this.updateState(updates, { action: 'OPEN_POSITION', price, size, ...context });
  }

  /**
   * Close position (SELL) - partial or full.
   *
   * @async
   * @param {number} price - Current market price in USD per BTC
   * @param {boolean} [partial=false] - true for partial close, false for full
   * @param {number|null} [size=null] - BTC amount to close (null = full position)
   * @param {Object} [context={}] - Additional context for logging/tracking
   * @returns {Promise<{success: boolean, state?: Object, error?: string}>}
   *
   * @example
   * // Full close at $101,000 (1% profit on $100k entry)
   * await stateManager.closePosition(101000);
   * // Result: pnl = 0.001 Ã— ($101k - $100k) = $1
   * //         balance += 0.001 Ã— $101,000 = $101
   *
   * @description
   * CRITICAL P&L CALCULATION (fixed 2026-02-01):
   * WRONG (old bug): pnl = closeSize Ã— priceChangePercent
   *   - Treated BTC as USD: 0.001 Ã— 0.01 = $0.00001 profit (WRONG!)
   * CORRECT: pnl = closeSize Ã— (price - entryPrice)
   *   - BTC Ã— price_diff = USD: 0.001 Ã— $1000 = $1 profit (CORRECT!)
   *
   * BALANCE RESTORATION (fixed 2026-02-01):
   * WRONG (old bug): balance += closeSize + pnl
   *   - Added BTC to USD: balance + 0.001 + 0.00001 (WRONG!)
   * CORRECT: balance += closeSize Ã— price
   *   - BTC Ã— current_price = USD returned: balance + $101 (CORRECT!)
   */
  async closePosition(price, partial = false, size = null, context = {}) {
    if (this.state.position <= 0) {
      console.error('[StateManager] No position to close!');
      return { success: false, error: 'No position to close' };
    }

    const closeSize = size || this.state.position;
    // CRITICAL BUGFIX 2026-02-01: Position is in BTC, not USD!
    // Previous code treated closeSize as USD, causing $99.99 loss on every trade
    // Example: 0.001 BTC position Ã— 0.01 percent = $0.00001 PnL (WRONG!)
    // Correct: 0.001 BTC Ã— $1000 price change = $1 PnL
    const pnl = closeSize * (price - this.state.entryPrice);  // BTC Ã— price diff = USD profit
    const priceChangePercent = this.state.entryPrice > 0
      ? ((price - this.state.entryPrice) / this.state.entryPrice)
      : 0;
    const pnlPercent = priceChangePercent * 100;

    // CRITICAL FIX: Remove closed trades from activeTrades Map
    // BUGFIX 2026-01-23: Clear ALL trades on full close, not just type='BUY'
    // Previous bug: trades with action='SELL' weren't removed, causing accumulation
    if (!partial && this.state.activeTrades && this.state.activeTrades.size > 0) {
      // Clear ALL active trades on full position close
      const tradeCount = this.state.activeTrades.size;
      for (const [id, trade] of this.state.activeTrades.entries()) {
        // Remove ALL trades (BUY or SELL) - no position means no active trades
        this.state.activeTrades.delete(id);
        console.log(`ğŸ”’ [StateManager] Removed trade ${id} (${trade.action || trade.type}) from activeTrades`);
      }
      console.log(`ğŸ“Š [StateManager] Cleared ${tradeCount} active trades on position close`);
    }

    // CRITICAL BUGFIX 2026-02-01: Balance was adding BTC amount instead of USD value!
    // closeSize is in BTC, we need to add back the USD value at current price
    // Previous: balance + closeSize + pnl â†’ balance + 0.001 + 0.00001 = wrong!
    // Correct: balance + (closeSize * price) â†’ balance + 101 = right!
    const usdValueReturned = closeSize * price;  // What we get back in USD

    // Calculate USD that was locked in position (at entry price)
    const usdCostLocked = closeSize * this.state.entryPrice;

    const updates = {
      position: Math.max(0, this.state.position - closeSize),
      positionCount: partial ? this.state.positionCount : 0,
      entryPrice: partial ? this.state.entryPrice : 0,
      entryTime: partial ? this.state.entryTime : null,
      balance: this.state.balance + usdValueReturned,  // Add back USD at current price
      inPosition: Math.max(0, this.state.inPosition - usdCostLocked),  // BUGFIX: Subtract USD, not BTC!
      realizedPnL: this.state.realizedPnL + pnl,
      totalPnL: this.state.totalPnL + pnl,
      totalBalance: this.state.totalBalance + pnl,  // BUGFIX: Track total value including profits
      lastTradeTime: Date.now()
    };

    console.log(`ğŸ“Š Position closed: PnL ${pnl > 0 ? '+' : ''}$${pnl.toFixed(2)} (${pnlPercent.toFixed(2)}%)`);

    return this.updateState(updates, {
      action: 'CLOSE_POSITION',
      price,
      size: closeSize,
      pnl,
      partial,
      ...context
    });
  }

  /**
   * Update balance (deposits, withdrawals, fees)
   */
  async updateBalance(amount, reason = 'adjustment') {
    const updates = {
      balance: this.state.balance + amount,
      totalBalance: this.state.totalBalance + amount
    };

    return this.updateState(updates, { action: 'BALANCE_UPDATE', amount, reason });
  }

  /**
   * Reset daily counters
   */
  async resetDaily() {
    const updates = {
      dailyTradeCount: 0
    };

    return this.updateState(updates, { action: 'DAILY_RESET' });
  }

  /**
   * Set recovery mode
   */
  async setRecoveryMode(enabled) {
    const updates = {
      recoveryMode: enabled
    };

    return this.updateState(updates, { action: 'RECOVERY_MODE', enabled });
  }

  /**
   * Validate state consistency
   */
  validateState() {
    const issues = [];

    // Check balance consistency
    const expectedTotal = this.state.balance + this.state.inPosition;
    const diff = Math.abs(expectedTotal - this.state.totalBalance);
    if (diff > 0.01) {
      issues.push(`Balance mismatch: total=${this.state.totalBalance}, expected=${expectedTotal}`);
    }

    // Check position consistency
    if (this.state.position > 0 && !this.state.entryPrice) {
      issues.push('Position exists but no entry price');
    }

    if (this.state.position === 0 && this.state.inPosition > 0) {
      issues.push('No position but funds locked');
    }

    if (this.state.position < 0) {
      issues.push('Negative position detected!');
    }

    if (this.state.balance < 0) {
      issues.push('Negative balance detected!');
    }

    return {
      valid: issues.length === 0,
      issues
    };
  }

  /**
   * Emergency state reset (use with caution!)
   */
  async emergencyReset(safeBalance = null) {
    console.warn('ğŸš¨ [StateManager] EMERGENCY RESET INITIATED');

    const updates = {
      position: 0,
      positionCount: 0,
      entryPrice: 0,
      entryTime: null,
      balance: safeBalance || this.state.totalBalance,
      totalBalance: safeBalance || this.state.totalBalance,
      inPosition: 0,
      activeTrades: new Map(),
      recoveryMode: true
    };

    return this.updateState(updates, { action: 'EMERGENCY_RESET' });
  }

  /**
   * Pause trading for safety
   * @param {string} reason - Why trading is being paused
   */
  async pauseTrading(reason) {
    console.log('ğŸ›‘ [StateManager] PAUSING TRADING:', reason);

    const updates = {
      isTrading: false,
      lastError: reason,
      pausedAt: Date.now(),
      pauseReason: reason
    };

    await this.updateState(updates, { action: 'PAUSE_TRADING', reason });

    // Log to console with visible warning
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log('ğŸš¨ TRADING PAUSED - SAFETY STOP');
    console.log(`   Reason: ${reason}`);
    console.log(`   Time: ${new Date().toISOString()}`);
    console.log('   Action Required: Review logs and resume manually');
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

    return { success: true, message: `Trading paused: ${reason}` };
  }

  /**
   * Resume trading after pause
   */
  async resumeTrading() {
    console.log('âœ… [StateManager] RESUMING TRADING');

    const updates = {
      isTrading: true,
      lastError: null,
      pausedAt: null,
      pauseReason: null,
      resumedAt: Date.now()
    };

    await this.updateState(updates, { action: 'RESUME_TRADING' });

    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log('âœ… TRADING RESUMED');
    console.log(`   Time: ${new Date().toISOString()}`);
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

    return { success: true, message: 'Trading resumed' };
  }

  // === CHANGE 2025-12-13: STEP 1 - ACTIVE TRADES MANAGEMENT ===

  /**
   * Add or update an active trade
   */
  updateActiveTrade(orderId, tradeData) {
    console.log(`ğŸ” [StateManager] updateActiveTrade called with orderId: ${orderId}`);
    console.log(`ğŸ” [StateManager] this.get exists: ${typeof this.get}`);
    console.log(`ğŸ” [StateManager] this.set exists: ${typeof this.set}`);

    const trades = this.get('activeTrades') || new Map();
    console.log(`ğŸ” [StateManager] Got trades: ${trades instanceof Map ? 'Map' : typeof trades}`);

    trades.set(orderId, tradeData);
    console.log(`ğŸ” [StateManager] About to call this.set with activeTrades`);

    this.set('activeTrades', trades);
    this.save(); // Save to disk with Map serialization
    console.log(`ğŸ“ [StateManager] Updated trade ${orderId}`);
  }

  /**
   * Remove an active trade
   */
  removeActiveTrade(orderId) {
    const trades = this.get('activeTrades');
    if (trades && trades.has(orderId)) {
      trades.delete(orderId);
      this.set('activeTrades', trades);
      this.save(); // Save to disk with Map serialization
      console.log(`ğŸ—‘ï¸ [StateManager] Removed trade ${orderId}`);
    }
  }

  /**
   * Get all active trades as array
   */
  getAllTrades() {
    const trades = this.get('activeTrades');
    return trades ? Array.from(trades.values()) : [];
  }

  /**
   * Check if state is in sync
   */
  isInSync() {
    const validation = this.validateState();
    if (!validation.valid) {
      console.error('âŒ [StateManager] STATE DESYNC DETECTED:', validation.issues);
    }
    return validation.valid;
  }

  // === CHANGE 2025-12-13: CRITICAL - MAP SERIALIZATION FOR PERSISTENCE ===

  /**
   * Save state to disk with Map serialization
   */
  save() {
    try {
      // Skip state saving in backtest mode - don't corrupt real state
      if (process.env.BACKTEST_MODE === 'true') {
        return;
      }

      const fs = require('fs');
      const path = require('path');
      const dataDir = process.env.DATA_DIR || path.join(__dirname, '..', 'data');
      const stateFile = path.join(dataDir, 'state.json');

      // Create data directory if it doesn't exist
      if (!fs.existsSync(dataDir)) {
        fs.mkdirSync(dataDir, { recursive: true });
      }

      // Prepare state for serialization
      const stateToSave = { ...this.state };

      // CRITICAL: Convert Map to Array for JSON serialization
      if (this.state.activeTrades instanceof Map) {
        stateToSave.activeTrades = Array.from(this.state.activeTrades.entries());
      }

      // Save to disk
      fs.writeFileSync(stateFile, JSON.stringify(stateToSave, null, 2));
      console.log('[StateManager] State saved to disk');
    } catch (error) {
      console.error('[StateManager] Failed to save state:', error);
    }
  }

  /**
   * Load state from disk with Map deserialization
   */
  load() {
    try {
      // Skip state loading in backtest mode - start fresh
      if (process.env.BACKTEST_MODE === 'true') {
        console.log('[StateManager] BACKTEST_MODE: Starting with clean state');
        return;
      }

      // CHANGE 2026-01-23: Option to start fresh in paper mode
      // Set FRESH_START=true to reset paper trading state on boot
      if (process.env.FRESH_START === 'true') {
        console.log('[StateManager] FRESH_START: Resetting to clean $10k state');
        this.state.balance = 10000;
        this.state.totalBalance = 10000;
        this.state.position = 0;
        this.state.positionCount = 0;
        this.state.entryPrice = 0;
        this.state.entryTime = null;
        this.state.inPosition = 0;
        this.state.activeTrades = new Map();
        this.state.tradeCount = 0;
        this.state.dailyTradeCount = 0;
        this.state.realizedPnL = 0;
        this.state.unrealizedPnL = 0;
        this.state.totalPnL = 0;
        this.save(); // Persist the clean state
        return;
      }

      const fs = require('fs');
      const path = require('path');
      const dataDir = process.env.DATA_DIR || path.join(__dirname, '..', 'data');
      const stateFile = path.join(dataDir, 'state.json');

      if (fs.existsSync(stateFile)) {
        const savedState = JSON.parse(fs.readFileSync(stateFile, 'utf8'));

        // CRITICAL: Convert Array back to Map
        if (Array.isArray(savedState.activeTrades)) {
          savedState.activeTrades = new Map(savedState.activeTrades);
        } else if (!savedState.activeTrades) {
          savedState.activeTrades = new Map();
        }

        // Restore state
        this.state = { ...this.state, ...savedState };
        console.log('[StateManager] State loaded from disk');

        // Verify Map restoration
        console.log(`[StateManager] Active trades restored: ${this.state.activeTrades.size} trades`);
      }
    } catch (error) {
      console.error('[StateManager] Failed to load state:', error);
      // Initialize empty Map if load fails
      this.state.activeTrades = new Map();
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SECTION: Internal Methods (Lock, Validation, Logging)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * Validate state updates before applying.
   * Throws if updates would create invalid state.
   *
   * @private
   * @param {Object} updates - Proposed state updates
   * @throws {Error} If updates would create negative position or balance
   */
  validateUpdates(updates) {
    // Add validation logic here
    if (updates.position !== undefined && updates.position < 0) {
      throw new Error('Cannot set negative position');
    }
    if (updates.balance !== undefined && updates.balance < 0) {
      throw new Error('Cannot set negative balance');
    }
  }

  /**
   * Log a transaction for debugging/audit purposes.
   * Maintains a rolling window of the last N transactions.
   *
   * @private
   * @param {Object} transaction - Transaction record
   * @param {number} transaction.timestamp - When transaction occurred
   * @param {Object} transaction.updates - What was changed
   * @param {Object} transaction.context - Why it was changed
   * @param {Object} transaction.snapshot - State before change
   */
  logTransaction(transaction) {
    this.transactionLog.push(transaction);
    if (this.transactionLog.length > this.maxLogSize) {
      this.transactionLog.shift();
    }
  }

  /**
   * Acquire exclusive lock for atomic operations.
   * Uses a simple queue-based mutex to ensure only one update runs at a time.
   *
   * @private
   * @async
   * @returns {Promise<void>} Resolves when lock is acquired
   */
  async acquireLock() {
    if (!this.locked) {
      this.locked = true;
      return;
    }

    // Wait for lock to be available
    await new Promise(resolve => {
      this.lockQueue.push(resolve);
    });
    this.locked = true;  // CRITICAL: Must set after wait completes
  }

  releaseLock() {
    if (this.lockQueue.length > 0) {
      const next = this.lockQueue.shift();
      this.locked = false;  // Release lock
      next();  // Wake next waiter
    } else {
      this.locked = false;  // Only release if no queue
    }
  }

  // === LISTENERS ===

  addListener(callback) {
    this.listeners.add(callback);
  }

  removeListener(callback) {
    this.listeners.delete(callback);
  }

  notifyListeners(updates, context) {
    for (const listener of this.listeners) {
      try {
        listener(updates, context, this.getState());
      } catch (error) {
        console.error('[StateManager] Listener error:', error);
      }
    }

    // CHANGE 2025-12-11: Broadcast to dashboard AFTER state changes
    // This ensures dashboard always shows accurate, post-update state
    this.broadcastToDashboard(updates, context);
  }

  // === DASHBOARD INTEGRATION ===
  // CHANGE 2025-12-11: Dashboard gets state AFTER updates, never stale data

  setDashboardWs(ws) {
    this.dashboardWs = ws;
    console.log('[StateManager] Dashboard WebSocket connected');
  }

  broadcastToDashboard(updates, context) {
    if (!this.dashboardWs || this.dashboardWs.readyState !== 1) return;

    try {
      const state = this.getState();
      this.dashboardWs.send(JSON.stringify({
        type: 'state_update',
        source: 'StateManager',
        updates: updates,
        context: context,
        state: {
          position: state.position,
          balance: state.balance,
          totalBalance: state.totalBalance,
          realizedPnL: state.realizedPnL,
          unrealizedPnL: state.unrealizedPnL,
          totalPnL: state.totalPnL,
          tradeCount: state.tradeCount,
          dailyTradeCount: state.dailyTradeCount,
          recoveryMode: state.recoveryMode
        },
        timestamp: Date.now()
      }));
    } catch (error) {
      // Silent fail - don't let dashboard issues affect trading
    }
  }

  // === DEBUGGING ===

  getTransactionLog() {
    return [...this.transactionLog];
  }

  printState() {
    console.log('\nğŸ“Š === STATE SNAPSHOT ===');
    console.log(`Position: ${this.state.position} @ ${this.state.entryPrice || 'N/A'}`);
    console.log(`Balance: $${this.state.balance.toFixed(2)} (Total: $${this.state.totalBalance.toFixed(2)})`);
    console.log(`P&L: $${this.state.totalPnL.toFixed(2)} (Realized: $${this.state.realizedPnL.toFixed(2)})`);
    console.log(`Trades: ${this.state.tradeCount} total, ${this.state.dailyTradeCount} today`);
    console.log(`Recovery Mode: ${this.state.recoveryMode}`);
    console.log('======================\n');
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION: Module Exports (Singleton Pattern)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/** @type {StateManager|null} Singleton instance */
let instance = null;

/**
 * Get the singleton StateManager instance.
 * Creates the instance on first call, returns existing on subsequent calls.
 *
 * @function getInstance
 * @returns {StateManager} The singleton StateManager instance
 *
 * @example
 * const { getInstance } = require('./core/StateManager');
 * const stateManager = getInstance();
 * const state = stateManager.getState();
 */
module.exports = {
  getInstance: () => {
    if (!instance) {
      instance = new StateManager();
    }
    return instance;
  },
  /** @type {typeof StateManager} The StateManager class (for testing) */
  StateManager
};