/**
 * ============================================================================
 * OgzTpoIntegration.js - Two-Pole Oscillator Integration Layer
 * ============================================================================
 *
 * PURPOSE: Bridge the new OGZ TPO indicator into the existing trading flow
 * 
 * ARCHITECTURAL ROLE:
 * - Wraps the pure-function ogzTwoPoleOscillator for stateful use
 * - Provides voting system integration for ensemble decisions
 * - Manages dual-TPO A/B testing (new vs existing)
 * - Calculates dynamic SL/TP using ATR
 * - Ready for Empire V2 migration (modular, feature-flagged)
 *
 * EMPIRE V2 READY:
 * - Uses TierFeatureFlags for tier-based behavior
 * - Event-driven architecture for decoupling
 * - Pure indicator math separated from strategy logic
 * - Configurable via JSON profiles
 *
 * @author OGZPrime Team (Opus-Valhalla)
 * @version 1.0.0
 * @since 2025-12
 * ============================================================================
 */

const EventEmitter = require('events');

// Import the pure-function TPO
let computeOgzTpo, detectTpoCrossover, calculateDynamicLevels;
try {
    const ogzTpo = require('../src/indicators/ogzTwoPoleOscillator');
    computeOgzTpo = ogzTpo.computeOgzTpo;
    detectTpoCrossover = ogzTpo.detectTpoCrossover;
    calculateDynamicLevels = ogzTpo.calculateDynamicLevels;
    console.log('‚úÖ OgzTwoPoleOscillator loaded successfully');
} catch (e) {
    console.error('‚ùå OgzTwoPoleOscillator module not found at ../src/indicators/ogzTwoPoleOscillator');
    console.error('   Error:', e.message);
}

// Try to import existing TPO for A/B testing
let ExistingTwoPoleOscillator;
try {
    ExistingTwoPoleOscillator = require('./TwoPoleOscillator');
} catch (e) {
    console.log('‚ÑπÔ∏è Existing TwoPoleOscillator not available for A/B');
}

class OgzTpoIntegration extends EventEmitter {
    constructor(config = {}) {
        super();
        
        // Configuration with defaults
        this.config = {
            enabled: config.enabled ?? true,
            mode: config.mode || 'standard',           // 'standard' | 'aggressive' | 'conservative'
            dynamicSL: config.dynamicSL ?? true,
            confluence: config.confluence ?? false,     // Require both TPOs to agree
            voteWeight: config.voteWeight ?? 0.25,
            adaptive: config.adaptive ?? false,
            
            // TPO parameters
            tpoLength: config.tpoLength || 20,
            normLength: config.normLength || 25,
            volLength: config.volLength || 20,
            lagBars: config.lagBars || 4,
            
            // Mode-specific adjustments
            modes: {
                conservative: { minStrength: 0.03, zoneRequired: true, voteMultiplier: 0.8 },
                standard: { minStrength: 0.02, zoneRequired: false, voteMultiplier: 1.0 },
                aggressive: { minStrength: 0.01, zoneRequired: false, voteMultiplier: 1.2 }
            },
            
            ...config
        };
        
        // Candle history for batch processing
        this.candleHistory = {
            closes: [],
            highs: [],
            lows: [],
            timestamps: []
        };
        this.maxHistory = config.maxHistory || 200;
        
        // Last computed results
        this.lastResult = null;
        this.lastSignal = null;
        
        // Existing TPO for A/B testing
        this.existingTpo = ExistingTwoPoleOscillator ? 
            new ExistingTwoPoleOscillator({
                smaLength: this.config.normLength,
                filterLength: this.config.tpoLength
            }) : null;
        
        // Statistics for A/B comparison
        this.stats = {
            newTpoSignals: 0,
            existingTpoSignals: 0,
            confluenceMatches: 0,
            totalUpdates: 0
        };
        
        console.log(`üéØ OgzTpoIntegration initialized`);
        console.log(`   Mode: ${this.config.mode}`);
        console.log(`   Dynamic SL: ${this.config.dynamicSL ? 'YES' : 'NO'}`);
        console.log(`   Confluence: ${this.config.confluence ? 'ENABLED' : 'DISABLED'}`);
        console.log(`   Vote Weight: ${this.config.voteWeight}`);
    }
    
    /**
     * Initialize from TierFeatureFlags
     * @param {TierFeatureFlags} tierFlags - Feature flags instance
     */
    static fromTierFlags(tierFlags) {
        if (!tierFlags.isEnabled('ogzTpoEnabled')) {
            return null;
        }
        
        return new OgzTpoIntegration({
            enabled: true,
            mode: tierFlags.getValue('ogzTpoMode') || 'standard',
            dynamicSL: tierFlags.isEnabled('ogzTpoDynamicSL'),
            confluence: tierFlags.isEnabled('ogzTpoConfluence'),
            voteWeight: tierFlags.getValue('ogzTpoVoteWeight') || 0.25,
            adaptive: tierFlags.isEnabled('ogzTpoAdaptive')
        });
    }
    
    /**
     * Update with new candle data
     * @param {Object} candle - OHLC candle {o, h, l, c, t}
     * @returns {Object} Update result with signals and votes
     */
    update(candle) {
        if (!this.config.enabled || !computeOgzTpo) {
            return { enabled: false };
        }
        
        // Add to history
        this.candleHistory.closes.push(candle.c);
        this.candleHistory.highs.push(candle.h);
        this.candleHistory.lows.push(candle.l);
        this.candleHistory.timestamps.push(candle.t);
        
        // Trim to max history
        if (this.candleHistory.closes.length > this.maxHistory) {
            this.candleHistory.closes.shift();
            this.candleHistory.highs.shift();
            this.candleHistory.lows.shift();
            this.candleHistory.timestamps.shift();
        }
        
        this.stats.totalUpdates++;
        
        // Need minimum data for calculation
        if (this.candleHistory.closes.length < this.config.normLength + 5) {
            return { 
                enabled: true, 
                ready: false, 
                message: `Warming up (${this.candleHistory.closes.length}/${this.config.normLength + 5})` 
            };
        }
        
        // Compute new TPO
        const tpoResult = computeOgzTpo({
            closes: this.candleHistory.closes,
            highs: this.candleHistory.highs,
            lows: this.candleHistory.lows,
            tpoLength: this.config.tpoLength,
            normLength: this.config.normLength,
            volLength: this.config.volLength,
            lagBars: this.config.lagBars
        });
        
        this.lastResult = tpoResult;
        
        const lastIdx = this.candleHistory.closes.length - 1;
        
        // Detect signals from new TPO
        const newSignal = detectTpoCrossover(tpoResult, lastIdx);
        
        // Update existing TPO if available (for A/B)
        let existingSignal = null;
        if (this.existingTpo) {
            const existingResult = this.existingTpo.update(candle.c);
            existingSignal = existingResult.signal;
        }
        
        // Track statistics
        if (newSignal && newSignal.type !== 'INVALID') this.stats.newTpoSignals++;
        if (existingSignal && existingSignal.type !== 'INVALID') this.stats.existingTpoSignals++;
        
        // Confluence check
        let confluenceMatch = false;
        if (newSignal && existingSignal) {
            const newAction = newSignal.action;
            const existingAction = existingSignal.type;
            if (newAction === existingAction) {
                confluenceMatch = true;
                this.stats.confluenceMatches++;
            }
        }
        
        // Apply mode settings
        const modeSettings = this.config.modes[this.config.mode] || this.config.modes.standard;
        
        // Determine final signal based on configuration
        let finalSignal = null;
        
        if (newSignal && newSignal.type !== 'INVALID') {
            const meetsStrength = newSignal.strength >= modeSettings.minStrength;
            const meetsZone = !modeSettings.zoneRequired || newSignal.highProbability;
            const meetsConfluence = !this.config.confluence || confluenceMatch;
            
            if (meetsStrength && meetsZone && meetsConfluence) {
                finalSignal = {
                    ...newSignal,
                    source: 'ogzTpo',
                    confluenceConfirmed: confluenceMatch,
                    mode: this.config.mode,
                    price: candle.c,
                    timestamp: Date.now()
                };
                
                // Calculate dynamic levels if enabled
                if (this.config.dynamicSL) {
                    const vol = tpoResult.vol[lastIdx];
                    const direction = newSignal.action === 'BUY' ? 'LONG' : 'SHORT';
                    const levels = calculateDynamicLevels(candle.c, vol, direction);
                    finalSignal.levels = levels;
                }
                
                this.lastSignal = finalSignal;
                
                // Emit event for decoupled architecture
                this.emit('signal', finalSignal);
                
                console.log(`\nüéØ OGZ TPO SIGNAL: ${finalSignal.action}`);
                console.log(`   Zone: ${finalSignal.zone}`);
                console.log(`   Strength: ${(finalSignal.strength * 100).toFixed(2)}%`);
                console.log(`   High Probability: ${finalSignal.highProbability ? '‚≠ê YES' : 'NO'}`);
                console.log(`   Confluence: ${finalSignal.confluenceConfirmed ? '‚úÖ CONFIRMED' : '‚ùå NEW TPO ONLY'}`);
                if (finalSignal.levels) {
                    console.log(`   Dynamic SL: $${finalSignal.levels.stopLoss.toFixed(2)}`);
                    console.log(`   Dynamic TP: $${finalSignal.levels.takeProfit.toFixed(2)}`);
                }
            }
        }
        
        return {
            enabled: true,
            ready: true,
            tpo: tpoResult.tpo[lastIdx],
            tpoLag: tpoResult.tpoLag[lastIdx],
            norm: tpoResult.norm[lastIdx],
            vol: tpoResult.vol[lastIdx],
            bands: tpoResult.bands,
            signal: finalSignal,
            newTpoRaw: newSignal,
            existingTpoRaw: existingSignal,
            confluenceMatch,
            stats: this.stats
        };
    }
    
    /**
     * Get votes for the ensemble voting system
     * Compatible with OptimizedIndicators.getAllVotes()
     * @returns {Array} Array of vote objects
     */
    getVotes() {
        if (!this.lastSignal || !this.config.enabled) {
            return [];
        }
        
        const votes = [];
        const modeSettings = this.config.modes[this.config.mode] || this.config.modes.standard;
        const weight = this.config.voteWeight * modeSettings.voteMultiplier;
        
        // Main signal vote
        if (this.lastSignal.action === 'BUY') {
            votes.push({
                tag: `TPO:${this.lastSignal.zone}`,
                vote: 1,
                strength: weight * (this.lastSignal.highProbability ? 1.5 : 1.0)
            });
        } else if (this.lastSignal.action === 'SELL') {
            votes.push({
                tag: `TPO:${this.lastSignal.zone}`,
                vote: -1,
                strength: weight * (this.lastSignal.highProbability ? 1.5 : 1.0)
            });
        }
        
        // Confluence bonus vote
        if (this.lastSignal.confluenceConfirmed) {
            votes.push({
                tag: 'TPO:confluence',
                vote: this.lastSignal.action === 'BUY' ? 1 : -1,
                strength: 0.1 // Bonus for confirmation
            });
        }
        
        return votes;
    }
    
    /**
     * Get TPO state for dashboard/visualization
     * @returns {Object} Current TPO state
     */
    getState() {
        if (!this.lastResult) {
            return { ready: false };
        }
        
        const lastIdx = this.candleHistory.closes.length - 1;
        
        return {
            ready: true,
            enabled: this.config.enabled,
            mode: this.config.mode,
            current: {
                tpo: this.lastResult.tpo[lastIdx],
                tpoLag: this.lastResult.tpoLag[lastIdx],
                norm: this.lastResult.norm[lastIdx],
                vol: this.lastResult.vol[lastIdx]
            },
            bands: this.lastResult.bands,
            lastSignal: this.lastSignal,
            stats: this.stats,
            history: {
                tpo: this.lastResult.tpo.slice(-50),
                tpoLag: this.lastResult.tpoLag.slice(-50)
            }
        };
    }
    
    /**
     * Get dynamic SL/TP levels for current price
     * @param {number} entryPrice - Entry price
     * @param {string} direction - 'LONG' or 'SHORT'
     * @param {number} multiplier - ATR multiplier (default from mode)
     * @returns {Object} Stop loss and take profit levels
     */
    getDynamicLevels(entryPrice, direction, multiplier = null) {
        if (!this.lastResult) {
            return null;
        }
        
        const lastIdx = this.candleHistory.closes.length - 1;
        const vol = this.lastResult.vol[lastIdx];
        
        // Use mode-appropriate multiplier if not specified
        if (!multiplier) {
            switch (this.config.mode) {
                case 'conservative': multiplier = 2.0; break;
                case 'aggressive': multiplier = 1.0; break;
                default: multiplier = 1.5;
            }
        }
        
        return calculateDynamicLevels(entryPrice, vol, direction, multiplier);
    }
    
    /**
     * Reset state (useful for backtesting)
     */
    reset() {
        this.candleHistory = { closes: [], highs: [], lows: [], timestamps: [] };
        this.lastResult = null;
        this.lastSignal = null;
        this.stats = {
            newTpoSignals: 0,
            existingTpoSignals: 0,
            confluenceMatches: 0,
            totalUpdates: 0
        };
        
        if (this.existingTpo) {
            // Reset existing TPO state
            this.existingTpo.oscillatorHistory = [];
            this.existingTpo.filteredHistory = [];
            this.existingTpo.priceHistory = [];
            this.existingTpo.smooth1 = null;
            this.existingTpo.smooth2 = null;
        }
        
        console.log('üîÑ OgzTpoIntegration reset');
    }
    
    /**
     * Get configuration summary
     */
    getConfigSummary() {
        return {
            enabled: this.config.enabled,
            mode: this.config.mode,
            dynamicSL: this.config.dynamicSL,
            confluence: this.config.confluence,
            voteWeight: this.config.voteWeight,
            parameters: {
                tpoLength: this.config.tpoLength,
                normLength: this.config.normLength,
                volLength: this.config.volLength,
                lagBars: this.config.lagBars
            }
        };
    }
}

module.exports = OgzTpoIntegration;

// Also export static factory
module.exports.fromTierFlags = OgzTpoIntegration.fromTierFlags;
