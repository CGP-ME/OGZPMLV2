<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OGZPrime Unified Trading System - Live Dashboard</title>
    <!-- TradingView Lightweight Charts v4.1 -->
    <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700;800&family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --bg-primary: #000000;
            --bg-secondary: #0a0a0a;
            --bg-panel: rgba(20, 20, 20, 0.9);
            --border-color: rgba(255, 255, 255, 0.1);
            --text-primary: #ffffff;
            --text-secondary: #a0a0a0;
            
            /* Version-specific colors */
            --core-color: #00ccff;
            --ml-color: #ffd700;
            
            --profit-color: #00ff88;
            --loss-color: #ff3366;
            --neutral-color: #8b8b8b;
            
            --metallic-gradient: linear-gradient(135deg, #c0c0c0 0%, #808080 50%, #c0c0c0 100%);
            --core-gradient: linear-gradient(135deg, #00ccff 0%, #4dddff 50%, #00ccff 100%);
            --ml-gradient: linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #ffd700 100%);
        }
        
        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow-x: hidden;
            min-height: 100vh;
            position: relative;
        }
        
        /* Background effects */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 50%, rgba(255, 215, 0, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 80% 50%, rgba(0, 255, 255, 0.05) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }
        
        /* Header */
        .header {
            background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1e 100%);
            padding: 20px;
            text-align: center;
            border-bottom: 2px solid var(--profit-color);
            box-shadow: 0 4px 20px rgba(0, 255, 136, 0.3);
            position: relative;
            z-index: 10;
        }
        
        .logo {
            font-family: 'Orbitron', monospace;
            font-size: 42px;
            font-weight: 900;
            background: var(--metallic-gradient);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
            letter-spacing: 5px;
            text-shadow: 0 0 30px rgba(192, 192, 192, 0.5);
        }
        
        .tagline {
            color: #666666;
            font-size: 14px;
            margin-top: 5px;
            text-transform: uppercase;
            letter-spacing: 3px;
        }
        
        /* Tier Selector - Prominent placement */
        .tier-selector-container {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 15;
        }
        
        .tier-label {
            color: var(--ml-color);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 700;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .tier-selector {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--ml-color);
            color: var(--ml-color);
            padding: 10px 20px;
            border-radius: 8px;
            font-family: 'Orbitron', monospace;
            font-size: 14px;
            font-weight: 700;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            min-width: 250px;
        }
        
        .tier-selector:hover {
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            transform: translateY(-2px);
        }
        
        .tier-selector option {
            background: #000;
            color: #fff;
            padding: 5px;
        }
        
        /* Dynamic border color based on selected version */
        .tier-core .tier-selector { border-color: var(--core-color); color: var(--core-color); }
        .tier-ml .tier-selector { border-color: var(--ml-color); color: var(--ml-color); }
        
        .connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff0040;
            animation: statusPulse 2s infinite;
        }
        
        .status-dot.connected {
            background: var(--profit-color);
        }
        
        @keyframes statusPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }
        
        /* Main Container */
        .main-container {
            padding: 20px;
            position: relative;
            z-index: 5;
            max-width: 1600px;
            margin: 0 auto;
        }
        
        /* Unified Chart Section */
        .unified-chart-section {
            background: var(--bg-panel);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid var(--border-color);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.7);
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }
        
        /* Dynamic version border highlighting */
        .tier-core .unified-chart-section { border-color: var(--core-color); }
        .tier-ml .unified-chart-section { border-color: var(--ml-color); }
        
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .chart-title-container {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .chart-title {
            font-family: 'Orbitron', monospace;
            font-size: 28px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s ease;
        }
        
        .price-display {
            font-size: 20px;
            font-weight: 700;
            padding: 8px 20px;
            border-radius: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--profit-color);
            color: var(--profit-color);
            font-family: 'Orbitron', monospace;
        }
        
        /* Dynamic version coloring */
        .tier-core .chart-title {
            background: var(--core-gradient);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(0, 204, 255, 0.8);
        }

        .tier-ml .chart-title {
            background: var(--ml-gradient);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }
        
        .chart-controls {
            display: flex;
            gap: 10px;
        }

        .indicator-checkboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            background: rgba(26, 0, 0, 0.8);
            border: 1px solid #ff0040;
            border-radius: 5px;
            padding: 8px;
            max-width: 600px;
        }

        .indicator-check {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            user-select: none;
            font-size: 13px;  /* Increased from 11px */
            color: #fff;
            font-family: 'JetBrains Mono', monospace;
            padding: 3px 6px;
            border-radius: 3px;
            transition: background 0.2s;
        }

        .indicator-check:hover {
            background: rgba(255, 0, 64, 0.1);
        }

        .indicator-check input[type="checkbox"] {
            margin: 0;
            cursor: pointer;
        }

        .color-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        select, button {
            background: rgba(26, 0, 0, 0.8);
            color: #fff;
            border: 1px solid #ff0040;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 500;
            text-transform: uppercase;
            transition: all 0.3s;
        }
        
        select:hover, button:hover {
            background: #ff0040;
            box-shadow: 0 0 15px rgba(255, 0, 64, 0.6);
            transform: translateY(-2px);
        }
        
        /* Chart Container - TradingView */
        .chart-container {
            position: relative;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
            height: 600px;
            width: 100%;
        }
        
        #tvChartContainer {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }
        
        /* Multiple Bot Status Display */
        .bot-status-row {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 15px;
            z-index: 15;
        }
        
        .bot-status-indicator {
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;  /* Increased for readability */
            font-weight: 700;
            text-transform: uppercase;
            border: 1px solid;
            transition: all 0.3s ease;
        }
        
        .bot-status-indicator.core {
            background: rgba(0, 204, 255, 0.1);
            border-color: var(--core-color);
            color: var(--core-color);
        }

        .bot-status-indicator.ml {
            background: rgba(255, 215, 0, 0.1);
            border-color: var(--ml-color);
            color: var(--ml-color);
        }
        
        .bot-status-indicator.active {
            animation: botPulse 1s infinite;
        }
        
        @keyframes botPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Indicator Overlays */
        .indicator-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9) 0%, rgba(20, 20, 20, 0.9) 100%);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            padding: 12px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(255, 215, 0, 0.3);
            z-index: 10;
            min-width: 200px;
            transition: all 0.3s ease;
        }
        
        .indicator-overlay h4 {
            color: #ffd700;
            font-size: 12px;
            margin: 0 0 8px 0;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
        }
        
        .indicator-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 13px;  /* Increased for readability */
        }
        
        .indicator-label {
            color: #ccc;
        }
        
        .indicator-value {
            color: #ffd700;
            font-weight: bold;
            font-family: 'Orbitron', monospace;
        }
        
        /* Indicator panel visibility */
        .indicators-panel {
            display: none;
        }

        .tier-core .core-indicators {
            display: block;
        }

        .tier-ml .ml-indicators {
            display: block;
        }
        
        /* Trading Panel */
        .trading-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .panel-section {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9) 0%, rgba(20, 20, 20, 0.9) 100%);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(255, 215, 0, 0.2);
        }
        
        .panel-title {
            color: #ffd700;
            font-size: 16px;  /* Increased for better visibility */
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            border-bottom: 1px solid rgba(255, 215, 0, 0.3);
            padding-bottom: 8px;
        }
        
        /* Trade Controls */
        .trade-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .trade-btn {
            flex: 1;
            padding: 12px;
            font-weight: 700;
            font-family: 'Orbitron', monospace;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }
        
        .trade-btn:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        .trade-btn:hover:before {
            left: 100%;
        }
        
        .buy-btn {
            background: linear-gradient(135deg, #00ff41, #00cc33);
            color: #000;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
        }
        
        .sell-btn {
            background: linear-gradient(135deg, #ff4444, #cc1111);
            color: #fff;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.3);
        }
        
        .kill-btn {
            background: linear-gradient(135deg, #ff6600, #cc4400);
            color: #fff;
            box-shadow: 0 0 20px rgba(255, 102, 0, 0.3);
        }
        
        .long-btn {
            background: linear-gradient(135deg, #1e90ff, #0066cc);
            color: #fff;
            box-shadow: 0 0 20px rgba(30, 144, 255, 0.3);
        }
        
        .short-btn {
            background: linear-gradient(135deg, #9400d3, #6a0dad);
            color: #fff;
            box-shadow: 0 0 20px rgba(148, 0, 211, 0.3);
        }
        
        .hedge-btn {
            background: linear-gradient(135deg, #ff8c00, #cc7000);
            color: #fff;
            box-shadow: 0 0 20px rgba(255, 140, 0, 0.3);
        }
        
        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .stat-item {
            background: rgba(0, 0, 0, 0.6);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 215, 0, 0.2);
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .stat-item:hover {
            border-color: rgba(255, 215, 0, 0.4);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.2);
        }
        
        .stat-label {
            font-size: 13px;  /* Increased from 11px */
            color: #aaa;  /* Brightened from #888 */
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .stat-value {
            font-size: 16px;
            font-weight: 700;
            color: #ffd700;
            font-family: 'Orbitron', monospace;
        }
        
        .positive { color: var(--profit-color) !important; }
        .negative { color: var(--loss-color) !important; }
        
        /* Trade Log */
        .trade-log {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .trade-log-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin-bottom: 5px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 5px;
            font-size: 13px;  /* Increased for readability */
        }

        .trade-type {
            font-weight: 700;
            text-transform: uppercase;
        }

        .trade-time {
            color: #888;
            font-size: 12px;  /* Increased for readability */
        }

        .trade-duration {
            color: #666;
            font-size: 12px;  /* Increased for readability */
        }

        /* Chain of Thought */
        .chain-of-thought {
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 15px;
        }

        .thought-entry {
            padding: 10px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            border-left: 3px solid #ffd700;
        }

        .thought-step {
            font-size: 13px;  /* Increased for readability */
            margin-bottom: 5px;
            color: #ccc;
        }

        .thought-step strong {
            color: #ffd700;
        }

        /* Pattern Panel */
        .pattern-panel {
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.1) 0%, rgba(75, 0, 130, 0.1) 100%);
            border: 1px solid rgba(138, 43, 226, 0.4);
            border-radius: 12px;
            padding: 15px;
            margin-top: 15px;
        }

        .pattern-display {
            padding: 10px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
        }

        .pattern-name {
            font-weight: 700;
            color: #8a2be2;
            text-transform: uppercase;
            text-align: center;
            margin-bottom: 10px;
        }

        .pattern-visual {
            text-align: center;
            margin-bottom: 10px;
        }

        .pattern-description {
            font-size: 13px;  /* Increased for readability */
            color: #aaa;
        }

        .pattern-info {
            margin: 0;
            line-height: 1.4;
        }

        /* Neural Ensemble */
        .neural-ensemble {
            margin-top: 20px;
        }
        
        .ensemble-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
        }
        
        .brain-module {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(20, 20, 20, 0.9));
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .brain-module:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }
        
        .brain-name {
            font-size: 12px;  /* Increased for readability */
            color: #666666;
            margin-bottom: 5px;
            text-transform: uppercase;
        }
        
        .brain-vote {
            font-weight: 700;
            font-size: 14px;
            font-family: 'Orbitron', monospace;
        }
        
        .brain-confidence {
            font-size: 12px;  /* Increased for readability */
            color: #888;
            margin-top: 3px;
        }
        
        .vote-long { color: #00ff41; }
        .vote-short { color: #ff4444; }
        .vote-hedge { color: #ff8c00; }
        .vote-hold { color: #8b8b8b; }

        /* Upgrade Prompt */
        .upgrade-prompt {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.9), rgba(255, 140, 0, 0.9));
            color: #000;
            padding: 15px 30px;
            border-radius: 25px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.6);
            z-index: 100;
            display: none;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1a0000;
        }

        ::-webkit-scrollbar-thumb {
            background: #ffd700;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #ffed4e;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo">OGZPrime</div>
        <div class="tagline">Neural Ensemble ‚Ä¢ Real-Time Data</div>
        <div class="tier-selector-container">
            <span class="tier-label">SELECT VERSION:</span>
            <select id="tierSelector" class="tier-selector" onchange="switchTier(this.value)">
                <option value="ml">üß† ML VERSION - ALL FEATURES</option>
                <option value="core">‚ö° CORE VERSION</option>
            </select>
            <div class="connection-status">
                <span class="status-dot" id="connectionStatus"></span>
                <span id="statusText">Connecting...</span>
            </div>
        </div>
    </div>
    
    <div class="main-container">
        <!-- Unified Chart Section -->
        <div class="unified-chart-section tier-ml" id="unifiedChart">
            <div class="chart-header">
                <div class="chart-title-container">
                    <h2 class="chart-title" id="chartTitle">ML VERSION</h2>
                    <span class="price-display" id="currentPrice">$0.00</span>
                </div>
                <div class="chart-controls">
                    <select id="chartTypeSelector" onchange="changeChartType(this.value)">
                        <option value="candlestick" selected>Candlestick</option>
                        <option value="line">Line</option>
                    </select>
                    <select id="assetSelector" onchange="changeAsset(this.value)">
                        <option value="BTC-USD" selected>Bitcoin (BTC)</option>
                        <option value="ETH-USD">Ethereum (ETH)</option>
                        <option value="SOL-USD">Solana (SOL)</option>
                        <option value="XRP-USD">Ripple (XRP)</option>
                        <option value="ADA-USD">Cardano (ADA)</option>
                        <option value="DOT-USD">Polkadot (DOT)</option>
                        <option value="AVAX-USD">Avalanche (AVAX)</option>
                        <option value="LINK-USD">Chainlink (LINK)</option>
                        <option value="MATIC-USD">Polygon (MATIC)</option>
                        <option value="UNI-USD">Uniswap (UNI)</option>
                        <option value="ATOM-USD">Cosmos (ATOM)</option>
                        <option value="LTC-USD">Litecoin (LTC)</option>
                        <option value="DOGE-USD">Dogecoin (DOGE)</option>
                        <option value="SHIB-USD">Shiba Inu (SHIB)</option>
                        <option value="APT-USD">Aptos (APT)</option>
                    </select>
                    <select id="timeframeSelector" onchange="changeTimeframe(this.value)">
                        <option value="1m" selected>1M</option>
                        <option value="5m">5M</option>
                        <option value="15m">15M</option>
                        <option value="30m">30M</option>
                        <option value="1h">1H</option>
                        <option value="4h">4H</option>
                        <option value="1d">1D</option>
                    </select>
                    <div class="indicator-checkboxes" id="indicatorCheckboxes">
                        <label class="indicator-check">
                            <input type="checkbox" id="chk-ema" value="ema" onchange="updateIndicatorOverlays()">
                            <span class="color-dot" style="background: #ffcc00;"></span>
                            <span>EMA</span>
                        </label>
                        <label class="indicator-check">
                            <input type="checkbox" id="chk-sma" value="sma" onchange="updateIndicatorOverlays()">
                            <span class="color-dot" style="background: #00ccff;"></span>
                            <span>SMA</span>
                        </label>
                        <label class="indicator-check">
                            <input type="checkbox" id="chk-bollinger" value="bollinger" onchange="updateIndicatorOverlays()">
                            <span class="color-dot" style="background: #ff00cc;"></span>
                            <span>Bollinger Bands</span>
                        </label>
                        <label class="indicator-check">
                            <input type="checkbox" id="chk-atr" value="atr" onchange="updateIndicatorOverlays()">
                            <span class="color-dot" style="background: #ff6600;"></span>
                            <span>ATR</span>
                        </label>
                        <label class="indicator-check">
                            <input type="checkbox" id="chk-fibonacci" value="fibonacci" onchange="updateIndicatorOverlays()">
                            <span class="color-dot" style="background: #9900ff;"></span>
                            <span>Fibonacci</span>
                        </label>
                        <label class="indicator-check">
                            <input type="checkbox" id="chk-trendlines" value="trendlines" onchange="updateIndicatorOverlays()">
                            <span class="color-dot" style="background: #00ff00;"></span>
                            <span>Trend Lines</span>
                        </label>
                        <label class="indicator-check">
                            <input type="checkbox" id="chk-rsi" value="rsi" onchange="updateIndicatorOverlays()">
                            <span class="color-dot" style="background: #ff0066;"></span>
                            <span>RSI Overlay</span>
                        </label>
                        <label class="indicator-check">
                            <input type="checkbox" id="chk-macd" value="macd" onchange="updateIndicatorOverlays()">
                            <span class="color-dot" style="background: #6600ff;"></span>
                            <span>MACD Overlay</span>
                        </label>
                        <label class="indicator-check">
                            <input type="checkbox" id="chk-vwap" value="vwap" onchange="updateIndicatorOverlays()">
                            <span class="color-dot" style="background: #00ffcc;"></span>
                            <span>VWAP</span>
                        </label>
                        <label class="indicator-check">
                            <input type="checkbox" id="chk-ichimoku" value="ichimoku" onchange="updateIndicatorOverlays()">
                            <span class="color-dot" style="background: #ccff00;"></span>
                            <span>Ichimoku Cloud</span>
                        </label>
                        <label class="indicator-check">
                            <input type="checkbox" id="chk-sr" value="sr" onchange="updateIndicatorOverlays()">
                            <span class="color-dot" style="background: #ff9900;"></span>
                            <span>Support/Resistance</span>
                        </label>
                    </div>
                </div>
            </div>
            
            <div class="chart-container">
                <!-- TradingView Chart -->
                <div id="tvChartContainer"></div>
                
                <!-- Bot Status Indicators -->
                <div class="bot-status-row">
                    <div class="bot-status-indicator core" id="coreStatus">CORE</div>
                    <div class="bot-status-indicator ml active" id="mlStatus">ML</div>
                </div>
                
                <!-- Dynamic Indicator Overlay -->
                <div class="indicator-overlay" id="indicatorOverlay">
                    <h4>üìä Indicators</h4>

                    <!-- Core Indicators -->
                    <div class="indicators-panel core-indicators">
                        <div class="indicator-item">
                            <span class="indicator-label">RSI (14):</span>
                            <span class="indicator-value" id="rsiCore">50</span>
                        </div>
                        <div class="indicator-item">
                            <span class="indicator-label">MACD (12/26):</span>
                            <span class="indicator-value" id="macdCore">0.00</span>
                        </div>
                        <div class="indicator-item">
                            <span class="indicator-label">Pattern:</span>
                            <span class="indicator-value" id="patternCore">None</span>
                        </div>
                        <div class="indicator-item">
                            <span class="indicator-label">Volume:</span>
                            <span class="indicator-value" id="volumeCore">0</span>
                        </div>
                    </div>

                    <!-- ML Indicators (Full suite) -->
                    <div class="indicators-panel ml-indicators">
                        <div class="indicator-item">
                            <span class="indicator-label">RSI (14):</span>
                            <span class="indicator-value" id="rsiML">50</span>
                        </div>
                        <div class="indicator-item">
                            <span class="indicator-label">MACD (12/26):</span>
                            <span class="indicator-value" id="macdML">0.00</span>
                        </div>
                        <div class="indicator-item">
                            <span class="indicator-label">Pattern:</span>
                            <span class="indicator-value" id="patternML">None</span>
                        </div>
                        <div class="indicator-item">
                            <span class="indicator-label">Volume:</span>
                            <span class="indicator-value" id="volumeML">0</span>
                        </div>
                        <div class="indicator-item">
                            <span class="indicator-label">ATR:</span>
                            <span class="indicator-value" id="atrML">0.00</span>
                        </div>
                        <div class="indicator-item">
                            <span class="indicator-label">Confidence:</span>
                            <span class="indicator-value" id="confidenceML">0%</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Trading Panel -->
        <div class="trading-panel">
            <!-- Controls Section -->
            <div class="panel-section">
                <div class="panel-title">Trading Controls</div>
                <div class="trade-controls">
                    <button class="trade-btn buy-btn" onclick="executeTrade('buy')">BUY</button>
                    <button class="trade-btn sell-btn" onclick="executeTrade('sell')">SELL</button>
                    <button class="trade-btn kill-btn" onclick="executeTrade('kill')">KILL</button>
                </div>
                <div class="trade-controls">
                    <button class="trade-btn long-btn" onclick="executeTrade('long')">LONG</button>
                    <button class="trade-btn short-btn" onclick="executeTrade('short')">SHORT</button>
                    <button class="trade-btn hedge-btn" onclick="executeTrade('hedge')">HEDGE</button>
                </div>

                <!-- Pattern Recognition Panel -->
                <div class="pattern-panel">
                    <div class="panel-title">Pattern Analysis</div>
                    <div class="pattern-display" id="patternDisplay">
                        <div class="pattern-name" id="currentPatternName">Analyzing...</div>
                        <div class="pattern-visual" id="patternVisual">
                            <canvas id="patternCanvas" width="200" height="100"></canvas>
                        </div>
                        <div class="pattern-description" id="patternDescription">
                            <p class="pattern-info">Pattern detection active. When a pattern is identified, its visual representation and explanation will appear here.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Stats Section -->
            <div class="panel-section">
                <div class="panel-title">Performance Stats</div>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-label">Total P&L</div>
                        <div class="stat-value" id="totalPnl">$0.00</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Win Rate</div>
                        <div class="stat-value" id="winRate">0%</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Trades Executed</div>
                        <div class="stat-value" id="tradesExecuted">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Confidence</div>
                        <div class="stat-value" id="confidence">0%</div>
                    </div>
                </div>

                <!-- Trade Log -->
                <div class="panel-title">Trade Log</div>
                <div class="trade-log" id="tradeLog">
                </div>
            </div>
            
            <!-- Chain of Thought Section -->
            <div class="panel-section">
                <div class="panel-title">Chain of Thought</div>
                <div class="chain-of-thought" id="chainOfThought">
                    <div class="thought-entry" id="thoughtDisplay">
                        <p>Awaiting market data...</p>
                    </div>
                </div>

                <!-- Neural Ensemble Voting -->
                <div class="neural-ensemble">
                    <div class="panel-title">Neural Ensemble Voting</div>
                    <div class="ensemble-grid">
                        <div class="brain-module">
                            <div class="brain-name">Technical</div>
                            <div class="brain-vote vote-hold" id="technicalVote">HOLD</div>
                            <div class="brain-confidence" id="technicalConf">0%</div>
                        </div>
                        <div class="brain-module">
                            <div class="brain-name">Pattern</div>
                            <div class="brain-vote vote-hold" id="patternVote">HOLD</div>
                            <div class="brain-confidence" id="patternConf">0%</div>
                        </div>
                        <div class="brain-module">
                            <div class="brain-name">Momentum</div>
                            <div class="brain-vote vote-hold" id="momentumVote">HOLD</div>
                            <div class="brain-confidence" id="momentumConf">0%</div>
                        </div>
                        <div class="brain-module">
                            <div class="brain-name">Risk</div>
                            <div class="brain-vote vote-hold" id="riskVote">HOLD</div>
                            <div class="brain-confidence" id="riskConf">0%</div>
                        </div>
                        <div class="brain-module">
                            <div class="brain-name">Ensemble</div>
                            <div class="brain-vote vote-hold" id="ensembleVote">HOLD</div>
                            <div class="brain-confidence" id="ensembleConf">0%</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Upgrade Prompt -->
    <div class="upgrade-prompt" onclick="showUpgradeOptions()" style="display: none;">
        Contact for ML Version Access
    </div>
    
    <script>
        // ============================================
        // OGZPrime Dashboard - Complete TradingView Edition
        // All original functionality + TradingView charts + Indicator overlays
        // ============================================
        
        console.log('üöÄ OGZPrime Dashboard Loading...');
        
        // Global state
        let ws = null;
        let tvChart = null;
        let currentTier = 'ml';
        let tradesExecuted = 0;
        let lastPrice = 0;
        let currentChartType = 'candlestick';
        
        // Chart series
        let candleSeries = null;
        let lineSeries = null;
        let volumeSeries = null;
        
        // Indicator overlay series
        let ema20Series = null;
        let ema50Series = null;
        let ema200Series = null;
        let bbUpperSeries = null;
        let bbMiddleSeries = null;
        let bbLowerSeries = null;
        let vwapSeries = null;
        let superTrendSeries = null;
        
        // Active indicator overlays (all OFF by default)
        let activeOverlays = [];
        
        let botStates = {
            core: { connected: false, pnl: 0, trades: 0, confidence: 0 },
            ml: { connected: false, pnl: 0, trades: 0, confidence: 0 }
        };

        // Version configurations
        const tierConfigs = {
            core: {
                title: 'CORE VERSION',
                indicators: ['RSI', 'MACD', 'Pattern', 'Volume'],
                features: {
                    patterns: true,
                    neural: false,
                    chainOfThought: false
                }
            },
            ml: {
                title: 'ML VERSION',
                indicators: ['RSI', 'MACD', 'Pattern', 'Volume', 'ATR', 'Confidence', 'All Overlays'],
                features: {
                    patterns: true,
                    neural: true,
                    chainOfThought: true
                }
            }
        };

        // Trade button colors
        const tradeColors = {
            buy: '#00ff41',
            sell: '#ff4444',
            kill: '#ff6600',
            long: '#1e90ff',
            short: '#9400d3',
            hedge: '#ff8c00'
        };
        
        // Indicator colors
        const COLORS = {
            ema20: '#ffcc00',
            ema50: '#00ccff',
            ema200: '#ff6600',
            bbUpper: 'rgba(255, 255, 255, 0.4)',
            bbMiddle: 'rgba(255, 255, 255, 0.6)',
            bbLower: 'rgba(255, 255, 255, 0.4)',
            vwap: '#ff00ff',
            superTrendUp: '#00ff88',
            superTrendDown: '#ff3366'
        };
        
        // ============================================
        // CHART INITIALIZATION
        // ============================================
        
        function initChart() {
            console.log('üîç [Chart] Initializing TradingView chart...');
            
            if (typeof LightweightCharts === 'undefined') {
                console.error('‚ùå LightweightCharts not loaded!');
                return;
            }
            
            const container = document.getElementById('tvChartContainer');
            if (!container) {
                console.error('‚ùå Chart container not found!');
                return;
            }
            
            const rect = container.parentElement.getBoundingClientRect();
            
            tvChart = LightweightCharts.createChart(container, {
                width: rect.width - 20,
                height: rect.height - 20,
                layout: {
                    background: { type: 'solid', color: '#0a0a0a' },
                    textColor: '#d1d4dc',
                },
                grid: {
                    vertLines: { color: 'rgba(255, 255, 255, 0.06)' },
                    horzLines: { color: 'rgba(255, 255, 255, 0.06)' },
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                    vertLine: { color: 'rgba(255, 215, 0, 0.4)', width: 1, style: 2 },
                    horzLine: { color: 'rgba(255, 215, 0, 0.4)', width: 1, style: 2 },
                },
                rightPriceScale: {
                    borderColor: 'rgba(255, 255, 255, 0.1)',
                    scaleMargins: { top: 0.1, bottom: 0.2 },
                },
                timeScale: {
                    borderColor: 'rgba(255, 255, 255, 0.1)',
                    timeVisible: true,
                    secondsVisible: false,
                },
                localization: {
                    priceFormatter: price => '$' + price.toFixed(2),
                },
                handleScroll: {
                    mouseWheel: false,  // Disable scroll wheel zoom
                    pressedMouseMove: true,
                },
                handleScale: {
                    mouseWheel: false,  // Disable scroll wheel zoom
                    pinch: true,
                },
            });
            
            // Main price series
            candleSeries = tvChart.addCandlestickSeries({
                upColor: 'rgba(0, 255, 136, 0.8)',
                downColor: 'rgba(255, 51, 102, 0.8)',
                borderVisible: true,
                borderUpColor: '#00ff88',
                borderDownColor: '#ff3366',
                wickUpColor: '#00ff88',
                wickDownColor: '#ff3366',
                priceFormat: {
                    type: 'price',
                    precision: 2,
                    minMove: 0.01
                }
            });
            
            lineSeries = tvChart.addLineSeries({
                color: '#00ff88',
                lineWidth: 2,
                visible: false,
            });
            
            volumeSeries = tvChart.addHistogramSeries({
                priceFormat: { type: 'volume' },
                priceScaleId: '',
                scaleMargins: { top: 0.85, bottom: 0 },
            });
            
            // EMA lines
            ema20Series = tvChart.addLineSeries({
                color: COLORS.ema20,
                lineWidth: 1,
                visible: activeOverlays.includes('ema'),
            });
            
            ema50Series = tvChart.addLineSeries({
                color: COLORS.ema50,
                lineWidth: 1,
                visible: activeOverlays.includes('ema'),
            });
            
            ema200Series = tvChart.addLineSeries({
                color: COLORS.ema200,
                lineWidth: 2,
                visible: activeOverlays.includes('ema'),
            });
            
            // Bollinger Bands
            bbUpperSeries = tvChart.addLineSeries({
                color: COLORS.bbUpper,
                lineWidth: 1,
                visible: activeOverlays.includes('bollinger'),
                lineStyle: 2,
            });
            
            bbMiddleSeries = tvChart.addLineSeries({
                color: COLORS.bbMiddle,
                lineWidth: 1,
                visible: activeOverlays.includes('bollinger'),
            });
            
            bbLowerSeries = tvChart.addLineSeries({
                color: COLORS.bbLower,
                lineWidth: 1,
                visible: activeOverlays.includes('bollinger'),
                lineStyle: 2,
            });
            
            // VWAP
            vwapSeries = tvChart.addLineSeries({
                color: COLORS.vwap,
                lineWidth: 2,
                visible: activeOverlays.includes('vwap'),
            });
            
            // SuperTrend
            superTrendSeries = tvChart.addLineSeries({
                color: COLORS.superTrendUp,
                lineWidth: 2,
                visible: false,
            });
            
            // Resize handler
            window.addEventListener('resize', () => {
                if (tvChart) {
                    const r = container.parentElement.getBoundingClientRect();
                    tvChart.applyOptions({ width: r.width - 20, height: r.height - 20 });
                }
            });
            
            window.tvChart = tvChart;
            window.candleSeries = candleSeries;

            // Add crosshair move handler for OHLC display
            tvChart.subscribeCrosshairMove((param) => {
                if (!param || !param.seriesData || !param.time) {
                    document.getElementById('currentPrice').textContent = '$0.00';
                    return;
                }

                const data = param.seriesData.get(candleSeries);
                if (data) {
                    let displayText = '';
                    if (data.open !== undefined) {
                        // OHLC data available
                        displayText = `O: $${data.open.toFixed(2)} H: $${data.high.toFixed(2)} L: $${data.low.toFixed(2)} C: $${data.close.toFixed(2)}`;
                    } else if (data.value !== undefined) {
                        // Line series data
                        displayText = `$${data.value.toFixed(2)}`;
                    }
                    document.getElementById('currentPrice').textContent = displayText;
                }
            });

            console.log('‚úÖ TradingView chart initialized');
            
            // DO NOT LOAD FAKE DATA - wait for real Kraken data
            // loadPlaceholderData();  // REMOVED - was causing fake data issues
        }
        
        // REMOVED - This was generating FAKE random data!
        function loadPlaceholderData() {
            console.warn('‚ö†Ô∏è loadPlaceholderData DISABLED - only real Kraken data allowed');
            // DO NOT generate fake data - chart should start empty
            // Real data comes from WebSocket connection to Kraken
            return;
        }
        
        // ============================================
        // CHART UPDATE FUNCTIONS
        // ============================================
        
        function updateChart(data) {
            if (!candleSeries) return;

            const price = parseFloat(data.price || data.close);
            if (!price || isNaN(price) || price <= 0) return;
            
            // Update price display
            lastPrice = price;
            document.getElementById('currentPrice').textContent = '$' + price.toLocaleString('en-US', {
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            });

            let timestamp = data.candle?.timestamp || data.timestamp || Date.now();
            if (timestamp > 9999999999) timestamp = Math.floor(timestamp / 1000);

            // Update candle
            if (data.candle) {
                const candle = {
                    time: timestamp,
                    open: parseFloat(data.candle.open || price),
                    high: parseFloat(data.candle.high || price),
                    low: parseFloat(data.candle.low || price),
                    close: price,
                };

                if (currentChartType === 'candlestick') {
                    candleSeries.update(candle);
                } else {
                    lineSeries.update({ time: timestamp, value: price });
                }

                // Volume
                if (data.candle.volume) {
                    volumeSeries.update({
                        time: timestamp,
                        value: parseFloat(data.candle.volume),
                        color: candle.close >= candle.open ? 'rgba(0, 255, 136, 0.3)' : 'rgba(255, 51, 102, 0.3)',
                    });
                }
            }

            // Update indicator overlays
            if (data.indicators) {
                updateIndicatorOverlaysOnChart(timestamp, data.indicators);
                updateIndicatorValues(data.indicators);
            }
        }
        
        function updateIndicatorOverlaysOnChart(time, indicators) {
            // EMAs
            if (indicators.ema) {
                if (indicators.ema[20]) ema20Series.update({ time, value: indicators.ema[20] });
                if (indicators.ema[50]) ema50Series.update({ time, value: indicators.ema[50] });
                if (indicators.ema[200]) ema200Series.update({ time, value: indicators.ema[200] });
            }
            
            // Bollinger Bands
            if (indicators.bb) {
                if (indicators.bb.upper) bbUpperSeries.update({ time, value: indicators.bb.upper });
                if (indicators.bb.mid) bbMiddleSeries.update({ time, value: indicators.bb.mid });
                if (indicators.bb.lower) bbLowerSeries.update({ time, value: indicators.bb.lower });
            }
            
            // VWAP
            if (indicators.vwap) {
                vwapSeries.update({ time, value: indicators.vwap });
            }
            
            // SuperTrend
            if (indicators.superTrend && indicators.superTrend.value) {
                superTrendSeries.update({ time, value: indicators.superTrend.value });
                superTrendSeries.applyOptions({
                    color: indicators.superTrend.trend === 1 ? COLORS.superTrendUp : COLORS.superTrendDown
                });
            }
        }
        
        function loadHistoricalCandles(candles) {
            if (!candleSeries || !candles || !candles.length) return;
            
            const data = candles.map(c => {
                let t = c.t || c.timestamp;
                if (t > 9999999999) t = Math.floor(t / 1000);
                return {
                    time: t,
                    open: parseFloat(c.o || c.open),
                    high: parseFloat(c.h || c.high),
                    low: parseFloat(c.l || c.low),
                    close: parseFloat(c.c || c.close),
                };
            });
            
            candleSeries.setData(data);
            lineSeries.setData(data.map(d => ({ time: d.time, value: d.close })));
            console.log(`‚úÖ Loaded ${data.length} historical candles`);
        }
        
        // ============================================
        // WEBSOCKET
        // ============================================
        
        let reconnectTimer = null;
        let backoffMs = 250;
        let heartbeatInterval = null;
        let missedPongs = 0;

        // Heartbeat functions to keep WebSocket alive
        function startHeartbeat() {
            stopHeartbeat(); // Clear any existing heartbeat
            missedPongs = 0;

            heartbeatInterval = setInterval(() => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    missedPongs++;

                    // If we've missed 3 pongs, reconnect
                    if (missedPongs >= 3) {
                        console.warn('[WS] Missed 3 heartbeats, reconnecting...');
                        ws.close();
                        return;
                    }

                    // Send ping
                    ws.send(JSON.stringify({
                        type: 'ping',
                        timestamp: Date.now()
                    }));
                    console.log('[WS] Ping sent');
                }
            }, 30000); // Ping every 30 seconds
        }

        function stopHeartbeat() {
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = null;
            }
            missedPongs = 0;
        }

        function scheduleReconnect(url) {
            if (reconnectTimer) return;
            const wait = Math.min(backoffMs, 5000);
            backoffMs = Math.min(backoffMs * 2, 5000);
            console.log(`[WS] Reconnecting in ${wait}ms`);
            reconnectTimer = setTimeout(() => {
                reconnectTimer = null;
                connectWebSocket();
            }, wait);
        }

        function connectWebSocket() {
            const url = 'wss://ogzprime.com/ws';

            if (window.__ws && (window.__ws.readyState === WebSocket.OPEN || window.__ws.readyState === WebSocket.CONNECTING)) {
                return window.__ws;
            }

            console.log('[WS] Connecting to', url);
            ws = new WebSocket(url);
            window.__ws = ws;

            ws.addEventListener("open", () => {
                console.log('[WS] Connected');
                document.getElementById('connectionStatus').classList.add('connected');
                document.getElementById('statusText').textContent = 'Connected';
                backoffMs = 250;

                // Auth
                ws.send(JSON.stringify({
                    type: 'auth',
                    token: '39ccfbc54660e6075f07730285badebbc40d805748c8eeb7d7f2e32d15ae1c62'
                }));

                // Start heartbeat to keep connection alive
                startHeartbeat();
            });

            ws.addEventListener("error", (e) => {
                console.error('[WS] Error:', e);
            });

            ws.addEventListener("close", (e) => {
                console.log('[WS] Closed');
                document.getElementById('connectionStatus').classList.remove('connected');
                document.getElementById('statusText').textContent = 'Disconnected';
                stopHeartbeat();
                scheduleReconnect(url);
            });

            ws.addEventListener("message", (event) => {
                try {
                    const data = JSON.parse(event.data);
                    handleWebSocketMessage(data);
                } catch (err) {
                    console.error('[WS] Parse error:', err);
                }
            });

            return ws;
        }
        
        function handleWebSocketMessage(data) {
            // Auth success
            if (data.type === 'auth_success') {
                console.log('[WS] Auth successful');
                ws.send(JSON.stringify({
                    type: 'identify',
                    source: 'dashboard',
                    tier: currentTier,
                    version: '2.0.0'
                }));
                return;
            }

            if (data.type === 'error') {
                console.error('[WS] Error:', data.message);
                return;
            }

            // Handle pong response to reset missed count
            if (data.type === 'pong') {
                missedPongs = 0;
                console.log('[WS] Pong received');
                return;
            }

            // Price updates
            if (data.type === 'price' && data.data) {
                updateChart(data.data);
                
                // Historical candles on first load
                if (data.data.candles && data.data.candles.length > 0) {
                    loadHistoricalCandles(data.data.candles);
                }
            }

            // Trade messages
            else if (data.type === 'trade') {
                const botTier = data.botTier || data.tier || 'ml';
                const mappedTier = (botTier === 'quantum' || botTier === 'elite') ? 'ml' :
                                   (botTier === 'starter' || botTier === 'pro') ? 'core' : botTier;

                const tradeData = {
                    type: data.direction || data.action || 'trade',
                    price: data.price || lastPrice,
                    pnl: data.pnl || 0,
                    timestamp: data.timestamp || Date.now(),
                    duration: data.duration || null,
                    side: data.side || data.action,
                    direction: data.direction
                };

                addTradeToLog(tradeData);
                plotTradeSignal(tradeData);  // Add trade marker to chart

                updateBotStatus(mappedTier, data);
                updateStats(data);
            }

            // Bot status
            else if (data.type === 'bot_status') {
                const tier = data.tier || data.botTier || 'ml';
                const mappedTier = (tier === 'quantum' || tier === 'elite') ? 'ml' :
                                   (tier === 'starter' || tier === 'pro') ? 'core' : tier;
                botStates[mappedTier] = { ...botStates[mappedTier], ...data };
                updateBotStatusIndicators();
            }

            // Bot thinking - Chain of Thought
            else if (data.type === 'bot_thinking') {
                const thought = {
                    analysis: data.message || data.data?.reasoning || 'Processing...',
                    pattern: data.data?.pattern || 'Scanning...',
                    confidence: data.confidence || data.data?.finalConfidence || '0',
                    decision: data.data?.recommendation || 'Evaluating...',
                    rsi: data.data?.rsi,
                    trend: data.data?.trend,
                    riskScore: data.data?.riskScore
                };
                updateChainOfThought(thought);
            }

            // State updates
            else if (data.type === 'state_update') {
                if (data.state) {
                    if (data.state.totalPnL !== undefined) {
                        const pnl = data.state.totalPnL;
                        const el = document.getElementById('totalPnl');
                        el.textContent = `${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)}`;
                        el.className = `stat-value ${pnl >= 0 ? 'positive' : 'negative'}`;
                    }
                    if (data.state.tradeCount !== undefined) {
                        document.getElementById('tradesExecuted').textContent = data.state.tradeCount;
                    }
                }
            }

            // Pattern analysis
            else if (data.type === 'pattern_analysis') {
                const pattern = data.pattern || {};

                // Update pattern name
                document.getElementById('currentPatternName').textContent =
                    pattern.name || 'No Pattern';

                // Update description with confidence
                document.getElementById('patternDescription').innerHTML = `
                    <p class="pattern-info"><strong>Confidence:</strong> ${pattern.confidence || 0}%</p>
                    <p class="pattern-info">${pattern.description || 'Analyzing market structure...'}</p>
                `;

                // Update pattern memory stats if available
                if (data.patternMemory) {
                    const mem = data.patternMemory;
                    document.getElementById('patternDescription').innerHTML += `
                        <p class="pattern-info" style="margin-top: 10px; color: #888;">
                            üß† ${mem.status} | ${mem.count} patterns learned | ${mem.uniquePatterns} unique
                        </p>
                    `;
                }

                // Draw pattern visualization if we have pattern data
                if (pattern.allPatterns && pattern.allPatterns.length > 0) {
                    drawPatternVisualization(pattern.allPatterns);
                }
            }

            // CRITICAL ADDITION - Trade signal plotting handler
            else if (data.type === 'trade_opened' && data.trade) {
                plotTradeSignal(data.trade);
            }

            // Neural votes
            else if (data.type === 'neural_vote') {
                updateNeuralVotes(data);
            }

            // Indicators
            else if (data.type === 'indicators') {
                updateIndicatorValues(data);
            }

            // Performance
            else if (data.type === 'performance_update') {
                if (data.data) {
                    if (data.data.winRate !== undefined) {
                        document.getElementById('winRate').textContent = `${data.data.winRate.toFixed(1)}%`;
                    }
                    if (data.data.totalPnl !== undefined) {
                        const pnl = data.data.totalPnl;
                        const el = document.getElementById('totalPnl');
                        el.textContent = `${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)}`;
                        el.className = `stat-value ${pnl >= 0 ? 'positive' : 'negative'}`;
                    }
                }
            }

            // Trade levels
            else if (data.type === 'trade_levels') {
                console.log('Trade levels:', data.fibLevels, data.srLevels);
            }
        }
        
        // ============================================
        // UI UPDATE FUNCTIONS (Original functionality)
        // ============================================
        
        function switchTier(tier) {
            currentTier = tier;
            const chartSection = document.getElementById('unifiedChart');

            chartSection.classList.remove('tier-core', 'tier-ml');
            chartSection.classList.add(`tier-${tier}`);

            document.getElementById('chartTitle').textContent = tierConfigs[tier].title;
            updateBotStatusIndicators();

            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'tier_change', tier }));
            }

            updateTierFeatures(tier);
        }
        
        function updateBotStatusIndicators() {
            ['core', 'ml'].forEach(tier => {
                const indicator = document.getElementById(`${tier}Status`);
                if (indicator) {
                    indicator.classList.toggle('active', botStates[tier].connected);
                }
            });
        }
        
        function updateTierFeatures(tier) {
            const config = tierConfigs[tier];

            const neuralEnsemble = document.querySelector('.neural-ensemble');
            if (neuralEnsemble) {
                neuralEnsemble.style.display = config.features.neural ? 'block' : 'none';
            }

            const chainOfThought = document.querySelector('.chain-of-thought');
            if (chainOfThought) {
                chainOfThought.style.display = config.features.chainOfThought ? 'block' : 'none';
            }

            const coreIndicators = document.querySelector('.core-indicators');
            const mlIndicators = document.querySelector('.ml-indicators');
            if (coreIndicators && mlIndicators) {
                coreIndicators.style.display = tier === 'core' ? 'block' : 'none';
                mlIndicators.style.display = tier === 'ml' ? 'block' : 'none';
            }
        }
        
        function updateIndicatorValues(data) {
            const indicators = data.indicators || data;
            
            if (indicators.rsi !== undefined) {
                ['rsiCore', 'rsiML'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.textContent = indicators.rsi.toFixed(1);
                });
            }
            
            if (indicators.macd) {
                const macd = indicators.macd.macd || indicators.macd;
                ['macdCore', 'macdML'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.textContent = (typeof macd === 'number' ? macd : 0).toFixed(2);
                });
            }
            
            if (indicators.pattern) {
                ['patternCore', 'patternML'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.textContent = indicators.pattern;
                });
                document.getElementById('currentPatternName').textContent = `Pattern: ${indicators.pattern}`;
            }
            
            // ML-specific
            if (currentTier === 'ml') {
                if (indicators.atr !== undefined) {
                    const el = document.getElementById('atrML');
                    if (el) el.textContent = indicators.atr.toFixed(2);
                }
                if (indicators.confidence !== undefined) {
                    const el = document.getElementById('confidenceML');
                    if (el) el.textContent = `${indicators.confidence}%`;
                }
            }
        }
        
        function updateNeuralVotes(data) {
            const votes = data.votes || {};
            Object.keys(votes).forEach(brain => {
                const voteEl = document.getElementById(`${brain}Vote`);
                const confEl = document.getElementById(`${brain}Conf`);
                if (voteEl) {
                    const vote = votes[brain].decision || votes[brain];
                    voteEl.textContent = vote;
                    voteEl.className = `brain-vote vote-${vote.toLowerCase()}`;
                }
                if (confEl && votes[brain].confidence !== undefined) {
                    confEl.textContent = `${votes[brain].confidence}%`;
                }
            });
        }
        
        function updateBotStatus(tier, data) {
            if (tier && botStates[tier]) {
                botStates[tier].connected = true;
                if (data.pnl !== undefined) botStates[tier].pnl += data.pnl;
                if (data.confidence !== undefined) botStates[tier].confidence = data.confidence;
                botStates[tier].trades++;
                updateBotStatusIndicators();
            }
        }
        
        function updateStats(data) {
            let totalPnl = 0;
            let avgConfidence = 0;
            let activeCount = 0;

            Object.keys(botStates).forEach(tier => {
                if (botStates[tier].connected) {
                    totalPnl += botStates[tier].pnl || 0;
                    avgConfidence += botStates[tier].confidence || 0;
                    activeCount++;
                }
            });

            if (activeCount > 0) avgConfidence /= activeCount;

            const pnlEl = document.getElementById('totalPnl');
            pnlEl.textContent = `${totalPnl >= 0 ? '+' : ''}$${totalPnl.toFixed(2)}`;
            pnlEl.className = `stat-value ${totalPnl >= 0 ? 'positive' : 'negative'}`;

            if (data.winRate !== undefined) {
                document.getElementById('winRate').textContent = `${data.winRate.toFixed(1)}%`;
            }

            document.getElementById('confidence').textContent = `${avgConfidence.toFixed(1)}%`;
            document.getElementById('tradesExecuted').textContent = tradesExecuted;
        }

        function addTradeToLog(trade) {
            const tradeLog = document.getElementById('tradeLog');
            const entry = document.createElement('div');
            entry.className = 'trade-log-entry';

            const isProfit = trade.pnl >= 0;
            const color = tradeColors[trade.type] || '#ffffff';

            entry.innerHTML = `
                <span class="trade-type" style="color: ${color}">${trade.type.toUpperCase()}</span>
                <span class="${isProfit ? 'positive' : 'negative'}">
                    ${isProfit ? '+' : ''}$${Math.abs(trade.pnl).toFixed(2)}
                </span>
                <span class="trade-time">${new Date(trade.timestamp).toLocaleTimeString()}</span>
                <span class="trade-duration">${trade.duration || 'N/A'}</span>
            `;

            tradeLog.insertBefore(entry, tradeLog.firstChild);
            while (tradeLog.children.length > 20) tradeLog.removeChild(tradeLog.lastChild);

            tradesExecuted++;
            document.getElementById('tradesExecuted').textContent = tradesExecuted;
        }

        function updateChainOfThought(thought) {
            const display = document.getElementById('thoughtDisplay');
            if (display && thought) {
                display.innerHTML = `
                    <p class="thought-step"><strong>üìä Analysis:</strong> ${thought.analysis}</p>
                    <p class="thought-step"><strong>üìà Trend:</strong> ${thought.trend || 'N/A'} | RSI: ${thought.rsi || 'N/A'}</p>
                    <p class="thought-step"><strong>üéØ Confidence:</strong> ${thought.confidence}%</p>
                    <p class="thought-step"><strong>‚ö†Ô∏è Risk Score:</strong> ${thought.riskScore || 'N/A'}%</p>
                    <p class="thought-step"><strong>üí° Decision:</strong> ${thought.decision}</p>
                `;
            }
        }

        // Simple pattern visualization on canvas
        function drawPatternVisualization(patterns) {
            const canvas = document.getElementById('patternCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw confidence bars for each pattern
            const barHeight = 15;
            const maxWidth = canvas.width - 20;

            patterns.slice(0, 5).forEach((p, i) => {
                const y = 10 + (i * (barHeight + 5));
                const width = (p.confidence / 100) * maxWidth;

                // Background
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.fillRect(10, y, maxWidth, barHeight);

                // Confidence bar
                ctx.fillStyle = p.confidence > 70 ? '#00ff41' : p.confidence > 40 ? '#ffd700' : '#ff4444';
                ctx.fillRect(10, y, width, barHeight);

                // Label
                ctx.fillStyle = '#fff';
                ctx.font = '10px JetBrains Mono';
                ctx.fillText(`${p.name}: ${p.confidence}%`, 15, y + 11);
            });
        }

        // CRITICAL ADDITION FROM OUR VERSION - Trade signal plotting
        function plotTradeSignal(trade) {
            if (!candleSeries) {
                console.warn('Chart not ready for trade plotting');
                return;
            }

            // Plot marker on the chart
            const isLong = trade.type === 'BUY' || trade.side === 'buy' || trade.direction === 'long';
            const marker = {
                time: trade.timestamp ? Math.floor(trade.timestamp / 1000) : Math.floor(Date.now() / 1000),
                position: isLong ? 'belowBar' : 'aboveBar',
                color: isLong ? '#00ff88' : '#ff3366',
                shape: isLong ? 'arrowUp' : 'arrowDown',
                text: `${isLong ? 'BUY' : 'SELL'} @ ${trade.price || lastPrice}`
            };

            // Get existing markers and add new one
            const existingMarkers = candleSeries.markers() || [];
            existingMarkers.push(marker);
            candleSeries.setMarkers(existingMarkers);

            // Also add to trade log
            const tradeData = {
                type: isLong ? 'buy' : 'sell',
                pnl: trade.pnl || 0,
                timestamp: trade.timestamp || Date.now()
            };
            updateTradeHistory(tradeData);

            console.log(`üìç Trade signal plotted: ${marker.text}`);
        }
        
        function executeTrade(action) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: `manual_${action}`,
                    tier: currentTier,
                    timestamp: Date.now()
                }));
            }
        }

        function changeChartType(type) {
            currentChartType = type;
            candleSeries.applyOptions({ visible: type === 'candlestick' });
            lineSeries.applyOptions({ visible: type === 'line' });

            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'chart_type_change', chartType: type }));
            }
        }

        function changeAsset(asset) {
            console.log('Asset changed to:', asset);
            candleSeries.setData([]);
            lineSeries.setData([]);

            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'asset_change', asset }));
            }
        }

        // Handle timeframe changes
        let currentTimeframe = '1m';
        function changeTimeframe(timeframe) {
            console.log('Timeframe changed to:', timeframe);
            currentTimeframe = timeframe;

            // Clear current chart data
            if (candleSeries) candleSeries.setData([]);
            if (lineSeries) lineSeries.setData([]);

            // Request new data with the selected timeframe
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'timeframe_change',
                    timeframe: timeframe,
                    asset: document.getElementById('assetSelector').value
                }));

                // Request historical data for the new timeframe
                ws.send(JSON.stringify({
                    type: 'request_historical',
                    timeframe: timeframe,
                    asset: document.getElementById('assetSelector').value,
                    limit: 500
                }));
            }

            // Update chart title to show timeframe
            const title = document.getElementById('chartTitle');
            if (title) {
                const tierText = currentTier === 'ml' ? 'ML VERSION' : 'CORE VERSION';
                title.textContent = `${tierText} - ${timeframe.toUpperCase()}`;
            }
        }

        function updateIndicatorOverlays() {
            const checkboxes = document.querySelectorAll('#indicatorCheckboxes input[type="checkbox"]:checked');
            activeOverlays = Array.from(checkboxes).map(cb => cb.value);
            console.log('Selected indicators:', activeOverlays);

            // Toggle visibility
            ema20Series.applyOptions({ visible: activeOverlays.includes('ema') });
            ema50Series.applyOptions({ visible: activeOverlays.includes('ema') });
            ema200Series.applyOptions({ visible: activeOverlays.includes('ema') });
            bbUpperSeries.applyOptions({ visible: activeOverlays.includes('bollinger') });
            bbMiddleSeries.applyOptions({ visible: activeOverlays.includes('bollinger') });
            bbLowerSeries.applyOptions({ visible: activeOverlays.includes('bollinger') });
            vwapSeries.applyOptions({ visible: activeOverlays.includes('vwap') });

            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'indicator_selection', indicators: activeOverlays }));
            }
        }

        function showUpgradeOptions() {
            alert('Contact sales@ogzprime.com for ML Version access!');
        }
        
        // ============================================
        // INITIALIZATION
        // ============================================
        
        window.onload = () => {
            console.log('üöÄ OGZPrime Dashboard Initializing...');
            
            initChart();
            connectWebSocket();
            switchTier('ml');

            setTimeout(() => {
                ['core', 'ml'].forEach(tier => {
                    botStates[tier].connected = true;
                });
                updateBotStatusIndicators();
            }, 2000);
            
            console.log('‚úÖ OGZPrime Dashboard Ready');
        };
    </script>
</body>
</html>