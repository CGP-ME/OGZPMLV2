<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OGZPrime Ultimate - AI Trading Intelligence</title>
    <!-- Fixed: Use compatible Chart.js version with proper adapters -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.4/moment.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@1.0.1/dist/chartjs-adapter-moment.min.js"></script>
    
    <style>
        :root {
            --primary-green: #00ff88;
            --primary-cyan: #00ffff;
            --primary-red: #ff4444;
            --warning-orange: #ffaa00;
            --dark-bg: #0a0a0a;
            --card-bg: #111111;
            --card-border: rgba(0, 255, 136, 0.2);
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --text-muted: #888888;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, var(--dark-bg) 0%, #0f1419 50%, #1a1f2e 100%);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Header */
        .header {
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(10px);
            border-bottom: 2px solid var(--primary-green);
            padding: 1rem 2rem;
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header-content {
            max-width: 1920px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .logo {
            font-size: 1.8rem;
            font-weight: bold;
            background: linear-gradient(45deg, var(--primary-green), var(--primary-cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0,255,136,0.5);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .connection-hub {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: rgba(0,0,0,0.5);
            border-radius: 20px;
            font-size: 0.85rem;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-dot.connected { background: var(--primary-green); }
        .status-dot.connecting { background: var(--warning-orange); }
        .status-dot.disconnected { background: var(--primary-red); }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }

        /* Mission Statement */
        .mission-statement {
            background: linear-gradient(135deg, rgba(0,255,136,0.1), rgba(0,255,255,0.1));
            border: 1px solid var(--primary-green);
            border-radius: 15px;
            padding: 1rem 2rem;
            margin: 1rem auto;
            max-width: 1200px;
            text-align: center;
            animation: glow 3s ease-in-out infinite;
        }

        @keyframes glow {
            0%, 100% { box-shadow: 0 0 20px rgba(0,255,136,0.3); }
            50% { box-shadow: 0 0 40px rgba(0,255,136,0.6); }
        }

        /* Main Layout */
        .main-container {
            max-width: 1920px;
            margin: 0 auto;
            padding: 1rem;
            display: grid;
            grid-template-columns: 1fr 1fr 400px;
            gap: 1rem;
            min-height: calc(100vh - 200px);
        }

        .panel {
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 15px;
            padding: 1.5rem;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .panel:hover {
            border-color: var(--primary-green);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.2);
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(0, 255, 136, 0.3);
        }

        .panel-title {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--primary-green);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Chart Section */
        .chart-controls {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .timeframe-btn {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid var(--primary-green);
            color: var(--text-primary);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.85rem;
        }

        .timeframe-btn:hover {
            background: rgba(0, 255, 136, 0.2);
        }

        .timeframe-btn.active {
            background: var(--primary-green);
            color: var(--dark-bg);
            font-weight: bold;
        }

        .chart-container {
            position: relative;
            height: 400px;
            margin-bottom: 1rem;
        }

        .price-display {
            text-align: center;
            margin-bottom: 1rem;
        }

        .current-price {
            font-size: 3rem;
            font-weight: bold;
            color: var(--primary-green);
            text-shadow: 0 0 20px rgba(0,255,136,0.5);
            font-family: 'Courier New', monospace;
        }

        .price-change {
            font-size: 1.5rem;
            margin-top: 0.5rem;
            font-weight: bold;
        }

        .price-change.positive { color: var(--primary-green); }
        .price-change.negative { color: var(--primary-red); }

        /* AI Brain Section */
        .ai-stream {
            max-height: 400px;
            overflow-y: auto;
            padding-right: 0.5rem;
        }

        .ai-thought {
            background: rgba(255,255,255,0.05);
            margin: 0.5rem 0;
            padding: 1rem;
            border-radius: 8px;
            border-left: 3px solid var(--primary-green);
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            animation: slideIn 0.5s ease;
        }

        .ai-thought.thinking { border-left-color: var(--warning-orange); }
        .ai-thought.buy { 
            border-left-color: var(--primary-green); 
            background: rgba(0,255,136,0.1);
        }
        .ai-thought.sell { 
            border-left-color: var(--primary-red); 
            background: rgba(255,68,68,0.1);
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .ai-timestamp {
            color: var(--text-muted);
            font-size: 0.75rem;
            margin-bottom: 0.5rem;
        }

        /* Technical Indicators */
        .indicators-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .indicator-card {
            background: rgba(0,255,136,0.05);
            padding: 1rem;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(0,255,136,0.2);
            transition: all 0.3s ease;
        }

        .indicator-card:hover {
            background: rgba(0,255,136,0.1);
            transform: translateY(-2px);
        }

        .indicator-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 0.5rem;
        }

        .indicator-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary-green);
            font-family: 'Courier New', monospace;
        }

        /* Confidence Meter */
        .confidence-meter {
            margin: 1rem 0;
        }

        .confidence-bar {
            width: 100%;
            height: 30px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-red), var(--warning-orange), var(--primary-green));
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 1rem;
        }

        .confidence-text {
            color: var(--dark-bg);
            font-weight: bold;
            font-size: 0.9rem;
        }

        /* Portfolio Section */
        .portfolio-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .stat-card {
            background: rgba(0,255,255,0.05);
            padding: 1rem;
            border-radius: 10px;
            border: 1px solid rgba(0,255,255,0.2);
        }

        .stat-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .stat-value {
            font-size: 1.3rem;
            font-weight: bold;
            color: var(--primary-cyan);
            font-family: 'Courier New', monospace;
        }

        /* Trading Activity */
        .trades-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .trade-entry {
            background: rgba(255,255,255,0.05);
            margin: 0.5rem 0;
            padding: 1rem;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            animation: slideIn 0.5s ease;
        }

        .trade-buy {
            border-left: 3px solid var(--primary-green);
            background: rgba(0,255,136,0.05);
        }

        .trade-sell {
            border-left: 3px solid var(--primary-red);
            background: rgba(255,68,68,0.05);
        }

        .trade-info {
            display: flex;
            flex-direction: column;
        }

        .trade-type {
            font-weight: bold;
            color: var(--text-primary);
        }

        .trade-time {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .trade-metrics {
            text-align: right;
        }

        .trade-price {
            font-weight: bold;
            color: var(--text-primary);
        }

        .trade-pnl {
            font-size: 0.85rem;
            font-weight: bold;
        }

        .trade-pnl.positive { color: var(--primary-green); }
        .trade-pnl.negative { color: var(--primary-red); }

        /* Houston Progress */
        .houston-progress {
            background: linear-gradient(135deg, rgba(255,215,0,0.1), rgba(255,165,0,0.1));
            border: 1px solid #ffd700;
            border-radius: 15px;
            padding: 1.5rem;
            margin-top: 1rem;
            text-align: center;
        }

        .houston-title {
            font-size: 1.2rem;
            color: #ffd700;
            margin-bottom: 1rem;
            font-weight: bold;
        }

        .houston-bar {
            width: 100%;
            height: 40px;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            overflow: hidden;
            position: relative;
        }

        .houston-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #ffa500);
            transition: width 1s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .houston-percentage {
            color: var(--dark-bg);
            font-weight: bold;
            font-size: 1.1rem;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        /* Verification Section */
        .verification-bar {
            background: rgba(0,0,0,0.5);
            padding: 1rem;
            text-align: center;
            border-top: 1px solid var(--primary-green);
        }

        .verify-links {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 0.5rem;
        }

        .verify-link {
            color: var(--text-primary);
            text-decoration: none;
            padding: 0.5rem 1rem;
            background: rgba(0,255,136,0.1);
            border: 1px solid var(--primary-green);
            border-radius: 8px;
            transition: all 0.3s ease;
            font-size: 0.85rem;
        }

        .verify-link:hover {
            background: var(--primary-green);
            color: var(--dark-bg);
            transform: translateY(-2px);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary-green);
            border-radius: 4px;
        }

        /* Mobile Responsive */
        @media (max-width: 1400px) {
            .main-container {
                grid-template-columns: 1fr 1fr;
            }
            
            .panel:nth-child(3) {
                grid-column: span 2;
            }
        }

        @media (max-width: 768px) {
            .main-container {
                grid-template-columns: 1fr;
            }
            
            .panel:nth-child(3) {
                grid-column: span 1;
            }
            
            .indicators-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .current-price {
                font-size: 2rem;
            }
        }

        /* Loading Animation */
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0,255,136,0.3);
            border-radius: 50%;
            border-top-color: var(--primary-green);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Pattern Alert */
        .pattern-alert {
            background: linear-gradient(135deg, rgba(255,215,0,0.2), rgba(255,165,0,0.2));
            border: 2px solid #ffd700;
            border-radius: 10px;
            padding: 1rem;
            margin: 1rem 0;
            text-align: center;
            animation: pattern-pulse 2s ease-in-out infinite;
        }

        @keyframes pattern-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .pattern-name {
            font-size: 1.2rem;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 0.5rem;
        }

        .pattern-confidence {
            color: var(--text-secondary);
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-content">
            <div class="logo">
                üß† OGZPrime Ultimate
                <span style="font-size: 0.8rem; font-weight: normal; color: var(--text-secondary);">v3.0</span>
            </div>
            
            <div class="connection-hub">
                <div class="connection-status">
                    <span class="status-dot connecting" id="botStatus"></span>
                    <span id="botStatusText">Bot: Connecting...</span>
                </div>
                <div class="connection-status">
                    <span class="status-dot connecting" id="dataStatus"></span>
                    <span id="dataStatusText">Data: Connecting...</span>
                </div>
                <div class="connection-status">
                    <span class="status-dot connected"></span>
                    <span>AI: Active</span>
                </div>
            </div>
        </div>
    </header>

    <!-- Mission Statement -->
    <div class="mission-statement">
        <strong>üöÄ Mission: Houston</strong> | 
        This bot is our ticket to financial freedom | 
        Blood, sweat, and tears went into this | 
        <span id="daysRunning">0</span> days of perseverance
    </div>

    <!-- Main Dashboard -->
    <div class="main-container">
        <!-- Chart & Analysis Panel -->
        <div class="panel">
            <div class="panel-header">
                <div class="panel-title">üìà Live Market Analysis</div>
                <select id="assetSelector" style="background: var(--card-bg); color: var(--text-primary); border: 1px solid var(--primary-green); padding: 0.5rem; border-radius: 8px;">
                    <option value="BTC-USD">Bitcoin (BTC)</option>
                    <option value="ETH-USD">Ethereum (ETH)</option>
                    <option value="SOL-USD">Solana (SOL)</option>
                    <option value="ADA-USD">Cardano (ADA)</option>
                </select>
            </div>

            <div class="price-display">
                <div class="current-price" id="currentPrice">$0.00</div>
                <div class="price-change" id="priceChange">Loading...</div>
            </div>

            <div class="chart-controls">
                <button class="timeframe-btn active" data-timeframe="1m">1m</button>
                <button class="timeframe-btn" data-timeframe="5m">5m</button>
                <button class="timeframe-btn" data-timeframe="15m">15m</button>
                <button class="timeframe-btn" data-timeframe="1h">1h</button>
                <button class="timeframe-btn" data-timeframe="4h">4h</button>
                <button class="timeframe-btn" data-timeframe="1d">1D</button>
            </div>

            <div class="chart-container">
                <canvas id="priceChart"></canvas>
            </div>

            <div class="indicators-grid">
                <div class="indicator-card">
                    <div class="indicator-label">RSI (14)</div>
                    <div class="indicator-value" id="rsiValue">--</div>
                </div>
                <div class="indicator-card">
                    <div class="indicator-label">MACD</div>
                    <div class="indicator-value" id="macdValue">--</div>
                </div>
                <div class="indicator-card">
                    <div class="indicator-label">Volume</div>
                    <div class="indicator-value" id="volumeValue">--</div>
                </div>
                <div class="indicator-card">
                    <div class="indicator-label">Trend</div>
                    <div class="indicator-value" id="trendValue">--</div>
                </div>
                <div class="indicator-card">
                    <div class="indicator-label">Volatility</div>
                    <div class="indicator-value" id="volatilityValue">--</div>
                </div>
                <div class="indicator-card">
                    <div class="indicator-label">Support</div>
                    <div class="indicator-value" id="supportValue">--</div>
                </div>
            </div>

            <div class="confidence-meter">
                <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                    <span>AI Confidence</span>
                    <span id="confidencePercent">0%</span>
                </div>
                <div class="confidence-bar">
                    <div class="confidence-fill" id="confidenceFill" style="width: 0%">
                        <span class="confidence-text"></span>
                    </div>
                </div>
            </div>

            <div id="patternAlert" class="pattern-alert" style="display: none;">
                <div class="pattern-name" id="patternName">--</div>
                <div class="pattern-confidence">Confidence: <span id="patternConfidence">--%</span></div>
            </div>
        </div>

        <!-- AI Brain Stream -->
        <div class="panel">
            <div class="panel-header">
                <div class="panel-title">üß† AI Decision Engine</div>
                <span style="color: var(--text-secondary); font-size: 0.85rem;">
                    <span class="loading-spinner" id="aiSpinner"></span>
                    <span id="aiStatus">Analyzing...</span>
                </span>
            </div>

            <div class="ai-stream" id="aiStream">
                <div class="ai-thought thinking">
                    <div class="ai-timestamp">System starting...</div>
                    <div>üß† Initializing OGZPrime AI neural networks...</div>
                </div>
            </div>

            <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.1);">
                <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                    <span>Next Analysis</span>
                    <span id="nextAnalysis">--</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span>Decisions Today</span>
                    <span id="decisionsToday">0</span>
                </div>
            </div>
        </div>

        <!-- Portfolio & Trading -->
        <div class="panel">
            <div class="panel-header">
                <div class="panel-title">üí∞ Portfolio & Trading</div>
            </div>

            <div class="portfolio-stats">
                <div class="stat-card">
                    <div class="stat-label">Balance</div>
                    <div class="stat-value" id="balance">$10,000.00</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Total P&L</div>
                    <div class="stat-value" id="totalPnL">$0.00</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Today's P&L</div>
                    <div class="stat-value" id="todayPnL">$0.00</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Win Rate</div>
                    <div class="stat-value" id="winRate">0%</div>
                </div>
            </div>

            <div style="margin: 1rem 0;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                    <span>Position</span>
                    <span id="positionStatus" style="font-weight: bold; color: var(--text-secondary);">No Position</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span>Risk Level</span>
                    <span id="riskLevel" style="font-weight: bold; color: var(--warning-orange);">Moderate</span>
                </div>
            </div>

            <div class="panel-header" style="margin-top: 1.5rem;">
                <div class="panel-title" style="font-size: 1rem;">‚ö° Live Trades</div>
            </div>

            <div class="trades-list" id="tradesList">
                <div style="text-align: center; color: var(--text-muted); padding: 2rem;">
                    Waiting for trading activity...
                </div>
            </div>

            <div class="houston-progress">
                <div class="houston-title">üöÄ Houston Progress</div>
                <div class="houston-bar">
                    <div class="houston-fill" id="houstonFill" style="width: 0%">
                        <span class="houston-percentage" id="houstonPercent">0%</span>
                    </div>
                </div>
                <div style="margin-top: 0.5rem; font-size: 0.85rem; color: var(--text-secondary);">
                    Goal: $25,000 | <span id="houstonRemaining">$15,000</span> to go
                </div>
            </div>
        </div>
    </div>

    <!-- Verification Bar -->
    <div class="verification-bar">
        <strong>üîç Verify Our Data:</strong>
        <div class="verify-links">
            <a href="https://www.tradingview.com/chart/?symbol=BINANCE:BTCUSDT" target="_blank" class="verify-link">üìä TradingView</a>
            <a href="https://www.binance.com/en/trade/BTC_USDT" target="_blank" class="verify-link">üîó Binance</a>
            <a href="https://coinmarketcap.com/currencies/bitcoin/" target="_blank" class="verify-link">üìà CoinMarketCap</a>
            <a href="https://polygon.io/" target="_blank" class="verify-link">üî∑ Polygon.io</a>
            <a href="https://finance.yahoo.com/quote/BTC-USD" target="_blank" class="verify-link">üì∞ Yahoo Finance</a>
        </div>
    </div>

    <script>
        class OGZPrimeUltimate {
            constructor() {
                console.log('üöÄ OGZPrime Ultimate Dashboard initializing...');
                
                // Configuration - LIVE DDNS SERVER
                this.config = {
                    wsEndpoint: 'wss://api.ogzprime.com:3010', // WebSocket to your home trading system
                    apiEndpoint: 'https://api.ogzprime.com:3010/api', // API to your home trading system
                    updateInterval: 10000,
                    chartMaxPoints: 100,
                    // Enhanced connection resilience settings
                    reconnectDelay: 3000,           // Initial reconnect delay
                    maxReconnectDelay: 30000,       // Maximum reconnect delay
                    reconnectDecay: 1.5,            // Exponential backoff multiplier
                    maxReconnectAttempts: 10,       // Maximum reconnection attempts
                    pingInterval: 30000,            // Ping interval for keepalive
                    connectionTimeout: 10000        // Connection timeout
                };
                
                // State
                this.state = {
                    currentAsset: 'BTC-USD',
                    currentTimeframe: '1m',
                    lastPrice: 0,
                    balance: 10000,
                    startBalance: 10000,
                    houstonGoal: 25000,
                    trades: [],
                    priceHistory: [],
                    indicators: {},
                    aiThoughts: [],
                    patterns: [],
                    position: null,
                    stats: {
                        totalTrades: 0,
                        wins: 0,
                        losses: 0,
                        totalProfit: 0,
                        todayProfit: 0
                    }
                };
                
                // WebSocket connections with resilience tracking
                this.botSocket = null;
                this.polygonSocket = null;
                this.botReconnectAttempts = 0;
                this.polygonReconnectAttempts = 0;
                this.botPingInterval = null;
                this.polygonPingInterval = null;
                
                // Chart instance
                this.chart = null;
                
                // Initialize everythingoooo
                this.init();
            }
            
            async init() {
                // Calculate days running
                const startDate = new Date('2025-04-20'); // Adjust to your actual start date
                const daysRunning = Math.floor((Date.now() - startDate) / (1000 * 60 * 60 * 24));
                document.getElementById('daysRunning').textContent = daysRunning;
                
                // Initialize chart
                this.initChart();
                
                // Connect to data sources
                this.connectBot();
                this.connectPolygon();
                
                // Setup event listeners
                this.setupEventListeners();
                
                // Start update loops
                this.startUpdateLoops();
                
                // Initial AI thought
                this.addAIThought('üöÄ OGZPrime Ultimate AI initialized. Ready to conquer the markets.', 'system');
                this.addAIThought('üí™ Remember: We persevered through crashes, debug sessions, and moments that would break strong men.', 'system');
                this.addAIThought('üéØ Mission: Get to Houston with your daughter. Let\'s make it happen.', 'system');
            }
            
            initChart() {
                const ctx = document.getElementById('priceChart').getContext('2d');
                
                this.chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Price',
                            data: [],
                            borderColor: '#00ffff',
                            backgroundColor: 'rgba(0, 255, 255, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.1,
                            pointRadius: 0,
                            pointHoverRadius: 5
                        }, {
                            label: 'Buy Signals',
                            data: [],
                            borderColor: '#00ff88',
                            backgroundColor: '#00ff88',
                            borderWidth: 0,
                            pointRadius: 8,
                            pointHoverRadius: 10,
                            showLine: false,
                            pointStyle: 'triangle'
                        }, {
                            label: 'Sell Signals',
                            data: [],
                            borderColor: '#ff4444',
                            backgroundColor: '#ff4444',
                            borderWidth: 0,
                            pointRadius: 8,
                            pointHoverRadius: 10,
                            showLine: false,
                            pointStyle: 'rectRot'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false
                        },
                        plugins: {
                            legend: {
                                display: true,
                                labels: { color: '#ffffff' }
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                backgroundColor: 'rgba(0, 0, 0, 0.9)',
                                titleColor: '#ffffff',
                                bodyColor: '#ffffff',
                                borderColor: '#00ff88',
                                borderWidth: 1
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'minute',
                                    displayFormats: { minute: 'HH:mm' }
                                },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { color: '#ffffff' }
                            },
                            y: {
                                beginAtZero: false,
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { 
                                    color: '#ffffff',
                                    callback: value => '$' + value.toLocaleString()
                                }
                            }
                        }
                    }
                });
            }
            
            connectBot() {
                try {
                    console.log(`üîå Attempting bot connection to ${this.config.wsEndpoint} (attempt ${this.botReconnectAttempts + 1})`);
                    this.updateConnectionStatus('bot', 'connecting');
                    
                    this.botSocket = new WebSocket(this.config.wsEndpoint);
                    
                    // Enhanced connection timeout with exponential backoff
                    const connectionTimeout = setTimeout(() => {
                        if (this.botSocket.readyState === WebSocket.CONNECTING) {
                            console.log('‚è∞ Bot connection timeout, will retry with backoff...');
                            this.botSocket.close();
                            this.handleBotReconnect();
                        }
                    }, this.config.connectionTimeout);
                    
                    this.botSocket.onopen = () => {
                        clearTimeout(connectionTimeout);
                        console.log('‚úÖ Connected to OGZPrime bot');
                        this.botReconnectAttempts = 0; // Reset on successful connection
                        this.updateConnectionStatus('bot', true);
                        this.addAIThought('üîó Connected to trading engine. Systems nominal.', 'system');
                        
                        // Enhanced ping system with connection health monitoring
                        this.botPingInterval = setInterval(() => {
                            if (this.botSocket.readyState === WebSocket.OPEN) {
                                this.botSocket.send(JSON.stringify({
                                    type: 'ping',
                                    timestamp: Date.now(),
                                    client: 'dashboard'
                                }));
                            } else {
                                console.warn('‚ö†Ô∏è Bot socket not open during ping, clearing interval');
                                clearInterval(this.botPingInterval);
                            }
                        }, this.config.pingInterval);
                        
                        // Request initial status
                        this.botSocket.send(JSON.stringify({ type: 'status_request' }));
                    };
                    
                    this.botSocket.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleBotMessage(data);
                        } catch (err) {
                            console.error('Bot message parse error:', err);
                        }
                    };
                    
                    this.botSocket.onclose = (event) => {
                        clearTimeout(connectionTimeout);
                        if (this.botPingInterval) {
                            clearInterval(this.botPingInterval);
                            this.botPingInterval = null;
                        }
                        
                        console.log(`‚ùå Bot disconnected (code: ${event.code}, reason: ${event.reason})`);
                        this.updateConnectionStatus('bot', false);
                        this.addAIThought('‚ö†Ô∏è Lost connection to trading engine. Attempting reconnection...', 'system');
                        
                        this.handleBotReconnect();
                    };
                    
                    this.botSocket.onerror = (error) => {
                        clearTimeout(connectionTimeout);
                        console.error('Bot WebSocket error:', error);
                        this.updateConnectionStatus('bot', false);
                    };
                    
                } catch (error) {
                    console.error('Bot connection error:', error);
                    this.updateConnectionStatus('bot', false);
                    this.handleBotReconnect();
                }
            }
            
            handleBotReconnect() {
                if (this.botReconnectAttempts >= this.config.maxReconnectAttempts) {
                    console.error('üíÄ Max bot reconnection attempts reached');
                    this.addAIThought('‚ùå Unable to reconnect to trading engine after maximum attempts', 'system');
                    return;
                }
                
                this.botReconnectAttempts++;
                
                // Calculate exponential backoff delay
                const delay = Math.min(
                    this.config.reconnectDelay * Math.pow(this.config.reconnectDecay, this.botReconnectAttempts - 1),
                    this.config.maxReconnectDelay
                );
                
                console.log(`üîÑ Bot reconnection attempt ${this.botReconnectAttempts} in ${delay}ms`);
                this.addAIThought(`üîÑ Reconnection attempt ${this.botReconnectAttempts} in ${(delay/1000).toFixed(1)}s`, 'system');
                
                setTimeout(() => this.connectBot(), delay);
            }
            
            connectPolygon() {
                // Use bot connection for data - no separate Polygon needed
                console.log('üì° Using bot connection for market data');
                this.updateConnectionStatus('data', 'connecting');
                
                // Check if bot is connected and use it for data
                if (this.botSocket && this.botSocket.readyState === WebSocket.OPEN) {
                    this.updateConnectionStatus('data', true);
                    console.log('‚úÖ Data connection established via bot');
                } else {
                    // Wait for bot connection
                    const checkBotConnection = setInterval(() => {
                        if (this.botSocket && this.botSocket.readyState === WebSocket.OPEN) {
                            this.updateConnectionStatus('data', true);
                            console.log('‚úÖ Data connection established via bot');
                            clearInterval(checkBotConnection);
                        }
                    }, 1000);
                    
                    // Timeout after 10 seconds
                    setTimeout(() => {
                        clearInterval(checkBotConnection);
                        if (!this.botSocket || this.botSocket.readyState !== WebSocket.OPEN) {
                            this.updateConnectionStatus('data', false);
                            console.log('‚ùå Data connection failed - bot not connected');
                        }
                    }, 10000);
                }
                return;
                
                try {
                    console.log(`üì° Attempting Polygon connection (attempt ${this.polygonReconnectAttempts + 1})`);
                    this.updateConnectionStatus('data', 'connecting');
                    
                    // Polygon WebSocket would go here if configured
                    this.polygonSocket = new WebSocket('wss://socket.polygon.io/crypto');
                    
                    this.polygonSocket.onopen = () => {
                        console.log('‚úÖ Connected to Polygon.io');
                        this.polygonReconnectAttempts = 0; // Reset on successful connection
                        this.updateConnectionStatus('data', true);
                        
                        // Authenticate with enhanced error handling
                        this.polygonSocket.send(JSON.stringify({
                            action: 'auth',
                            params: this.config.polygonKey
                        }));
                        
                        // Setup ping for Polygon connection
                        this.polygonPingInterval = setInterval(() => {
                            if (this.polygonSocket.readyState === WebSocket.OPEN) {
                                this.polygonSocket.send(JSON.stringify({
                                    action: 'ping',
                                    timestamp: Date.now()
                                }));
                            }
                        }, this.config.pingInterval);
                    };
                    
                    this.polygonSocket.onmessage = (event) => {
                        try {
                            const messages = JSON.parse(event.data);
                            const msgArray = Array.isArray(messages) ? messages : [messages];
                            
                            for (const msg of msgArray) {
                                this.handlePolygonMessage(msg);
                            }
                        } catch (err) {
                            console.error('Polygon message parse error:', err);
                        }
                    };
                    
                    this.polygonSocket.onclose = (event) => {
                        if (this.polygonPingInterval) {
                            clearInterval(this.polygonPingInterval);
                            this.polygonPingInterval = null;
                        }
                        
                        console.log(`‚ùå Polygon disconnected (code: ${event.code})`);
                        this.updateConnectionStatus('data', false);
                        this.handlePolygonReconnect();
                    };
                    
                    this.polygonSocket.onerror = (error) => {
                        console.error('Polygon WebSocket error:', error);
                        this.updateConnectionStatus('data', false);
                    };
                    
                } catch (error) {
                    console.error('Polygon connection error:', error);
                    this.updateConnectionStatus('data', false);
                    this.handlePolygonReconnect();
                }
            }
            
            handlePolygonReconnect() {
                if (this.polygonReconnectAttempts >= this.config.maxReconnectAttempts) {
                    console.error('üíÄ Max Polygon reconnection attempts reached');
                    return;
                }
                
                this.polygonReconnectAttempts++;
                
                // Calculate exponential backoff delay
                const delay = Math.min(
                    this.config.reconnectDelay * Math.pow(this.config.reconnectDecay, this.polygonReconnectAttempts - 1),
                    this.config.maxReconnectDelay
                );
                
                console.log(`üîÑ Polygon reconnection attempt ${this.polygonReconnectAttempts} in ${delay}ms`);
                
                setTimeout(() => this.connectPolygon(), delay);
            }
            
            handleBotMessage(data) {
                switch (data.type) {
                    case 'price':
                        // Use REAL price data from your SSL server
                        this.updatePrice(data.data.price, new Date(data.data.timestamp));
                        break;
                    case 'status':
                        this.handleStatus(data.data);
                        break;
                    case 'pong':
                        // Connection health check response
                        console.log('‚úÖ Bot connection healthy');
                        break;
                    default:
                        console.log('üì° Received real data:', data.type, data.data);
                }
            }
            
            handleStatus(data) {
                console.log('üìä Received REAL bot status:', data);
                
                // Handle REAL status updates from your bot
                if (data.balance !== undefined) {
                    this.state.balance = data.balance;
                    this.updatePortfolio();
                }
                
                if (data.tradesCount !== undefined) {
                    this.state.stats.totalTrades = data.tradesCount;
                    this.updatePortfolio();
                }
                
                if (data.decisionsToday !== undefined) {
                    document.getElementById('decisionsToday').textContent = data.decisionsToday;
                }
                
                if (data.currentPrice !== undefined) {
                    this.updatePrice(data.currentPrice, new Date());
                }
                
                if (data.position !== undefined) {
                    this.state.position = data.position;
                    const positionEl = document.getElementById('positionStatus');
                    if (data.position) {
                        positionEl.textContent = `${data.position.type} @ $${data.position.price.toFixed(2)}`;
                    } else {
                        positionEl.textContent = 'No Position';
                    }
                }
            }
            
            handlePolygonMessage(msg) {
                if (msg.status === 'auth_success') {
                    console.log('‚úÖ Polygon authenticated');
                    // Subscribe to crypto pair
                    this.polygonSocket.send(JSON.stringify({
                        action: 'subscribe',
                        params: `XA.${this.state.currentAsset.replace('-', '')}`
                    }));
                }
                
                // Handle price data
                if (msg.ev === 'XA' && msg.c) {
                    this.updatePrice(parseFloat(msg.c), new Date(msg.e));
                }
            }
            
            updatePrice(price, timestamp = new Date()) {
                const change = this.state.lastPrice ? price - this.state.lastPrice : 0;
                const changePercent = this.state.lastPrice ? (change / this.state.lastPrice) * 100 : 0;
                
                // Update display
                document.getElementById('currentPrice').textContent = `$${price.toLocaleString('en-US', {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                })}`;
                
                const changeEl = document.getElementById('priceChange');
                changeEl.textContent = `${change >= 0 ? '+' : ''}$${Math.abs(change).toFixed(2)} (${changePercent >= 0 ? '+' : ''}${changePercent.toFixed(2)}%)`;
                changeEl.className = `price-change ${change >= 0 ? 'positive' : 'negative'}`;
                
                // Update chart
                this.addPriceToChart(price, timestamp);
                
                // Update state
                this.state.lastPrice = price;
                
                // Real price data received - no fake analysis needed
                console.log(`üìà Real Bitcoin price: $${price.toFixed(2)}`);
            }
            
            addPriceToChart(price, timestamp) {
                this.state.priceHistory.push({ price, timestamp });
                
                // Keep max points
                if (this.state.priceHistory.length > this.config.chartMaxPoints) {
                    this.state.priceHistory.shift();
                }
                
                // Update chart data
                this.chart.data.labels = this.state.priceHistory.map(p => p.timestamp);
                this.chart.data.datasets[0].data = this.state.priceHistory.map(p => ({
                    x: p.timestamp,
                    y: p.price
                }));
                
                this.chart.update('none');
            }
            
            runAIAnalysis(price) {
                // Simulate technical indicators
                const rsi = 30 + Math.random() * 40;
                const macd = (Math.random() - 0.5) * 5;
                const volume = 1000000 + Math.random() * 5000000;
                const trend = Math.random() > 0.5 ? 'BULLISH' : 'BEARISH';
                const volatility = Math.random() * 3;
                const support = price * 0.98;
                
                // Update indicators
                document.getElementById('rsiValue').textContent = rsi.toFixed(1);
                document.getElementById('macdValue').textContent = macd.toFixed(2);
                document.getElementById('volumeValue').textContent = (volume / 1000000).toFixed(1) + 'M';
                document.getElementById('trendValue').textContent = trend;
                document.getElementById('volatilityValue').textContent = volatility.toFixed(1) + '%';
                document.getElementById('supportValue').textContent = '$' + support.toFixed(0);
                
                // AI confidence calculation
                let confidence = 50;
                let decision = 'HOLD';
                let reasoning = '';
                
                if (rsi < 35 && macd > 0 && trend === 'BULLISH') {
                    confidence = 75 + Math.random() * 20;
                    decision = 'BUY';
                    reasoning = `Oversold RSI (${rsi.toFixed(1)}) + Positive MACD (${macd.toFixed(2)}) + Bullish trend`;
                    this.addAIThought(`üí° Strong buy signal detected: ${reasoning}`, 'buy');
                } else if (rsi > 65 && macd < 0 && trend === 'BEARISH') {
                    confidence = 75 + Math.random() * 20;
                    decision = 'SELL';
                    reasoning = `Overbought RSI (${rsi.toFixed(1)}) + Negative MACD (${macd.toFixed(2)}) + Bearish trend`;
                    this.addAIThought(`‚ö†Ô∏è Strong sell signal detected: ${reasoning}`, 'sell');
                } else {
                    confidence = 30 + Math.random() * 40;
                    reasoning = 'Mixed signals - waiting for clearer market direction';
                    this.addAIThought(`ü§î ${reasoning}`, 'thinking');
                }
                
                // Update confidence meter
                this.updateConfidence(confidence);
                
                // Pattern detection
                if (Math.random() < 0.2) {
                    this.detectPattern();
                }
                
                // Execute trade on high confidence
                if (confidence > 85 && Math.random() < 0.3) {
                    this.executeTrade(decision, price, confidence);
                }
            }
            
            updateConfidence(confidence) {
                document.getElementById('confidenceFill').style.width = confidence + '%';
                document.getElementById('confidencePercent').textContent = confidence.toFixed(1) + '%';
            }
            
            detectPattern() {
                const patterns = [
                    'Double Bottom', 'Head & Shoulders', 'Bull Flag', 
                    'Ascending Triangle', 'Cup & Handle', 'Breakout'
                ];
                const pattern = patterns[Math.floor(Math.random() * patterns.length)];
                const confidence = 70 + Math.random() * 25;
                
                document.getElementById('patternAlert').style.display = 'block';
                document.getElementById('patternName').textContent = `üéØ ${pattern} Pattern Detected!`;
                document.getElementById('patternConfidence').textContent = confidence.toFixed(1) + '%';
                
                this.addAIThought(`üéØ Pattern recognition: ${pattern} with ${confidence.toFixed(1)}% confidence`, 'buy');
                
                setTimeout(() => {
                    document.getElementById('patternAlert').style.display = 'none';
                }, 10000);
            }
            
            executeTrade(type, price, confidence) {
                const trade = {
                    id: Date.now(),
                    type,
                    price,
                    timestamp: new Date(),
                    confidence,
                    status: 'open'
                };
                
                this.state.trades.push(trade);
                this.addTradeToList(trade);
                this.addTradeToChart(trade);
                
                this.addAIThought(`üöÄ EXECUTING ${type} @ $${price.toFixed(2)} (${confidence.toFixed(1)}% confidence)`, type.toLowerCase());
                
                // Update position
                document.getElementById('positionStatus').textContent = `${type} @ $${price.toFixed(2)}`;
                
                // Simulate trade completion
                setTimeout(() => {
                    this.completeTrade(trade);
                }, 5000 + Math.random() * 25000);
            }
            
            completeTrade(trade) {
                const priceChange = (Math.random() - 0.45) * 2; // Slight positive bias
                const exitPrice = trade.price * (1 + priceChange / 100);
                const profit = trade.type === 'BUY' 
                    ? (exitPrice - trade.price) * 0.1 * this.state.balance / trade.price
                    : (trade.price - exitPrice) * 0.1 * this.state.balance / trade.price;
                
                trade.exitPrice = exitPrice;
                trade.profit = profit;
                trade.status = 'closed';
                
                // Update stats
                this.state.stats.totalTrades++;
                if (profit > 0) {
                    this.state.stats.wins++;
                } else {
                    this.state.stats.losses++;
                }
                this.state.stats.totalProfit += profit;
                this.state.stats.todayProfit += profit;
                
                // Update balance
                this.state.balance += profit;
                this.updatePortfolio();
                
                // Add completion message
                const emoji = profit > 0 ? '‚úÖ' : '‚ùå';
                this.addAIThought(
                    `${emoji} Trade closed: ${profit >= 0 ? '+' : ''}$${profit.toFixed(2)} (${(profit / this.state.balance * 100).toFixed(2)}%)`,
                    profit > 0 ? 'buy' : 'sell'
                );
                
                // Clear position
                document.getElementById('positionStatus').textContent = 'No Position';
            }
            
            addTradeToList(trade) {
                const tradesContainer = document.getElementById('tradesList');
                
                // Clear placeholder
                if (tradesContainer.innerHTML.includes('Waiting for')) {
                    tradesContainer.innerHTML = '';
                }
                
                const tradeEl = document.createElement('div');
                tradeEl.className = `trade-entry trade-${trade.type.toLowerCase()}`;
                
                tradeEl.innerHTML = `
                    <div class="trade-info">
                        <div class="trade-type">${trade.type === 'BUY' ? 'üü¢ BUY' : 'üî¥ SELL'}</div>
                        <div class="trade-time">${trade.timestamp.toLocaleTimeString()}</div>
                    </div>
                    <div class="trade-metrics">
                        <div class="trade-price">$${trade.price.toFixed(2)}</div>
                        <div class="trade-pnl" id="trade-pnl-${trade.id}">Pending...</div>
                    </div>
                `;
                
                tradesContainer.insertBefore(tradeEl, tradesContainer.firstChild);
                
                // Keep only last 10 trades
                while (tradesContainer.children.length > 10) {
                    tradesContainer.removeChild(tradesContainer.lastChild);
                }
            }
            
            addTradeToChart(trade) {
                const datasetIndex = trade.type === 'BUY' ? 1 : 2;
                
                this.chart.data.datasets[datasetIndex].data.push({
                    x: trade.timestamp,
                    y: trade.price
                });
                
                this.chart.update('none');
            }
            
            addAIThought(thought, type = 'thinking') {
                const stream = document.getElementById('aiStream');
                
                const thoughtEl = document.createElement('div');
                thoughtEl.className = `ai-thought ${type}`;
                
                thoughtEl.innerHTML = `
                    <div class="ai-timestamp">${new Date().toLocaleTimeString()}</div>
                    <div>${thought}</div>
                `;
                
                stream.insertBefore(thoughtEl, stream.firstChild);
                
                // Keep only last 20 thoughts
                while (stream.children.length > 20) {
                    stream.removeChild(stream.lastChild);
                }
                
                // Update AI status
                document.getElementById('aiStatus').textContent = 'Processing...';
                setTimeout(() => {
                    document.getElementById('aiStatus').textContent = 'Analyzing...';
                }, 2000);
            }
            
            updatePortfolio() {
                // Update balance
                document.getElementById('balance').textContent = `$${this.state.balance.toFixed(2)}`;
                
                // Update P&L
                const totalPnL = this.state.balance - this.state.startBalance;
                const totalPnLEl = document.getElementById('totalPnL');
                totalPnLEl.textContent = `${totalPnL >= 0 ? '+' : ''}$${Math.abs(totalPnL).toFixed(2)}`;
                totalPnLEl.style.color = totalPnL >= 0 ? 'var(--primary-green)' : 'var(--primary-red)';
                
                // Update today's P&L
                const todayPnLEl = document.getElementById('todayPnL');
                todayPnLEl.textContent = `${this.state.stats.todayProfit >= 0 ? '+' : ''}$${Math.abs(this.state.stats.todayProfit).toFixed(2)}`;
                todayPnLEl.style.color = this.state.stats.todayProfit >= 0 ? 'var(--primary-green)' : 'var(--primary-red)';
                
                // Update win rate
                const winRate = this.state.stats.totalTrades > 0 
                    ? (this.state.stats.wins / this.state.stats.totalTrades * 100) 
                    : 0;
                document.getElementById('winRate').textContent = winRate.toFixed(1) + '%';
                
                // Update Houston progress
                this.updateHoustonProgress();
            }
            
            updateHoustonProgress() {
                const progress = Math.min((this.state.balance / this.state.houstonGoal) * 100, 100);
                const remaining = Math.max(this.state.houstonGoal - this.state.balance, 0);
                
                document.getElementById('houstonFill').style.width = progress + '%';
                document.getElementById('houstonPercent').textContent = progress.toFixed(1) + '%';
                document.getElementById('houstonRemaining').textContent = `$${remaining.toFixed(0)}`;
                
                // Celebrate milestones
                if (progress >= 100 && !this.state.houstonReached) {
                    this.state.houstonReached = true;
                    this.addAIThought('üéâüöÄ HOUSTON, WE HAVE LIFTOFF! Goal reached! Time to move to Houston with your daughter!', 'buy');
                } else if (progress >= 50 && !this.state.halfwayReached) {
                    this.state.halfwayReached = true;
                    this.addAIThought('üí™ HALFWAY TO HOUSTON! We\'re making it happen!', 'buy');
                }
            }
            
            updateConnectionStatus(type, status) {
                const statusEl = document.getElementById(`${type}Status`);
                const textEl = document.getElementById(`${type}StatusText`);
                
                if (status === true || status === 'connected') {
                    statusEl.className = 'status-dot connected';
                    textEl.textContent = `${type === 'bot' ? 'Bot' : 'Data'}: Connected`;
                } else if (status === 'connecting') {
                    statusEl.className = 'status-dot connecting';
                    textEl.textContent = `${type === 'bot' ? 'Bot' : 'Data'}: Connecting...`;
                } else {
                    statusEl.className = 'status-dot disconnected';
                    textEl.textContent = `${type === 'bot' ? 'Bot' : 'Data'}: Offline`;
                }
            }
            
            setupEventListeners() {
                // Timeframe buttons
                document.querySelectorAll('.timeframe-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.timeframe-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.state.currentTimeframe = e.target.dataset.timeframe;
                        this.addAIThought(`üìä Switched to ${e.target.dataset.timeframe} timeframe`, 'system');
                    });
                });
                
                // Asset selector
                document.getElementById('assetSelector').addEventListener('change', (e) => {
                    this.state.currentAsset = e.target.value;
                    this.addAIThought(`üí± Switched to ${e.target.value} trading pair`, 'system');
                    
                    // Resubscribe to new asset
                    if (this.polygonSocket && this.polygonSocket.readyState === WebSocket.OPEN) {
                        this.polygonSocket.send(JSON.stringify({
                            action: 'unsubscribe',
                            params: `XA.${this.state.currentAsset.replace('-', '')}`
                        }));
                        this.polygonSocket.send(JSON.stringify({
                            action: 'subscribe',
                            params: `XA.${e.target.value.replace('-', '')}`
                        }));
                    }
                });
            }
            
            startUpdateLoops() {
                // Update next analysis countdown
                setInterval(() => {
                    const seconds = Math.floor((Date.now() / 1000) % 60);
                    const nextAnalysis = 60 - seconds;
                    document.getElementById('nextAnalysis').textContent = `${nextAnalysis}s`;
                }, 1000);
                
                // Use real decision count from bot (will be updated via WebSocket)
                // No fake random numbers
                
                // Periodic status updates
                setInterval(() => {
                    if (this.botSocket && this.botSocket.readyState === WebSocket.OPEN) {
                        this.botSocket.send(JSON.stringify({ type: 'ping' }));
                    }
                }, 30000);
            }
        }
        
        // Initialize the ultimate dashboard
        document.addEventListener('DOMContentLoaded', () => {
            window.ogzPrime = new OGZPrimeUltimate();
        });
    </script>
</body>
</html>
